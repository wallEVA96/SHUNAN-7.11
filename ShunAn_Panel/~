#include "iostream.h"
using namespace std;
uint8 b_solve8x8_Ax_b(uint16 A[8][8], uint16 B[8])


uint8 b_solve8x8_Ax_b(uint16 A[8][8], uint16 B[8])
{
	// AX = B
	// 矩阵赋值[行][列]
	float AB[8][9];
	for (uint16 lineNum = 0; lineNum < 8; lineNum++)
	{
		for (uint8 RowCtr = 0; RowCtr < 8; RowCtr++)
		{
			AB[lineNum][RowCtr] = A[lineNum][RowCtr];
		}
	}
	for (uint8 ExRow_LineCtr = 0; ExRow_LineCtr<8; ExRow_LineCtr++)
	{
		AB[ExRow_LineCtr][9] = B[ExRow_LineCtr];
	}
	// 由于方程不满足平方根法，故采用n^3 / 6的算法 // 高斯淘汰法
	// [行][列]

	// 行消去
	for (uint8 Row_Ctr = 0; Row_Ctr < 8; Row_Ctr++)//选取每列，目标就是消去此列所有元素或只剩下一个1
	{
		// 求解每列
		for (uint8 Cal_Line_Ctr = Row_Ctr + 1; Cal_Line_Ctr < 8; Cal_Line_Ctr++)//行增广，列起始点与行同向
		{
			if (AB[Cal_Line_Ctr][Row_Ctr])//下一行元素是否为0
			{
				// 主元素不为0，消去本行所有元素
				float self_Line_GaiaNum = AB[Cal_Line_Ctr][Row_Ctr];//选取本行归一化数值
				for (uint8 self_Line_RowCtr = Row_Ctr; self_Line_RowCtr < 8; self_Line_RowCtr++)
				{
					AB[Cal_Line_Ctr][self_Line_RowCtr] = AB[Cal_Line_Ctr][self_Line_RowCtr] / self_Line_GaiaNum;//本行归一化
				}
				//删除本行外其余行的数值
				for (uint8 ExLine_Ctr = Cal_Line_Ctr + 1; ExLine_Ctr < 8; ExLine_Ctr++)//ExLine_Ctr从采集行下一行开始，列暂时不动
				{
					float Die_SammLikeGaiaLinesRow = AB[ExLine_Ctr][Row_Ctr] / AB[Cal_Line_Ctr][Row_Ctr];//获取消除增益
					for (uint8 ExLine_RowNumCtr = ExLine_Ctr; ExLine_RowNumCtr < 8; ExLine_RowNumCtr ++)
					{
						AB[ExLine_Ctr][ExLine_RowNumCtr] 
										= AB[ExLine_Ctr][ExLine_RowNumCtr] -//行固定，列增广
												Die_SammLikeGaiaLinesRow *  AB[Cal_Line_Ctr][ExLine_RowNumCtr];//
						//参数描述
					}
				}
			}
			else
			{//不为0，则需要查找除本行外其余行是否有非0元素。并进行变换。如果进行行变换，则会导致矩阵中元素混乱

			}
		}
	}
}
