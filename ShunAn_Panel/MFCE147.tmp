#include "arm_cm4.h"
#include "MK60F15.h"
#include "ShunAn_Lib.h"
#include "start_ShunAn.h"

#include "Pendulum_EndlessFormsMostBeautiful.h"

#include "Poet_ImageBeholder.h"//摄像头
#include "Poet_Revelation.h"//

#include "Poet_Buzzer.h"

#include "Poet_InputInterface.h"

s_Control m_Control = {0};//控制参数定义
s_ImageAbstract m_ImageAbstract = {0};//图像处理
unsigned short int u16_RevePanel[96][60];////图像数组

void v_ImageCutInformationShow()//===== -图像展示- =====//
{
    //if(0 == m_ImageAbstract.isImageInformationShowing)
    //{
    //    return;//如果不展示则退出
    //}
    s_color Red;
    Red.A_Blue_31 = 0;Red.B_Green_63 = 0;Red.C_Red_31 = 31;
    s_color Green;
    Green.A_Blue_31 = 0;Green.B_Green_63 = 63;Green.C_Red_31 = 0;
    s_color Blue;
    Blue.A_Blue_31 = 0;Blue.B_Green_63 = 0;Blue.C_Red_31 = 0;
    for(uint8 loop = m_ImageAbstract.Start_Y_Position;loop < m_ImageAbstract.Last_Y_Position;loop++)
    {
        if(255 != m_ImageAbstract.Right[loop])
        {
            v_ColorRev_PutPoint(m_ImageAbstract.Right[loop]/2,loop,&Red);
        }
        if(255 != m_ImageAbstract.Left[loop])
        {
            v_ColorRev_PutPoint(m_ImageAbstract.Left[loop]/2,loop,&Green);
        }
        if(255 != m_ImageAbstract.Central[loop])
        {
            v_ColorRev_PutPoint(m_ImageAbstract.Central[loop]/2,loop,&Blue);
        }
    }

}


float f_Get3pointsCurve(uint8 x_1,uint8 x_2,uint8 x_3,uint8 y_1,uint8 y_2,uint8 y_3)
{
    sint16 x_21_cut = (x_2 - x_1);
    sint16 x_32_cut = (x_3 - x_2);
    sint16 x_31_cut = (x_3 - x_1);
    sint16 y_21_cut = (y_2 - y_1);
    sint16 y_32_cut = (y_3 - y_2);
    sint16 y_31_cut = (y_3 - y_1);
    float S_4 = (x_21_cut * y_31_cut - x_31_cut * y_21_cut) * 2.f;//面积
    float l_12 = SquareRootBedivFloat(x_21_cut*x_21_cut + y_21_cut*y_21_cut);
    float l_23 = SquareRootBedivFloat(x_32_cut*x_32_cut + y_32_cut*y_32_cut);
    float l_13 = SquareRootBedivFloat(x_31_cut*x_31_cut + y_31_cut*y_31_cut);
    float curve = S_4 * l_12 * l_23 * l_13;
    return curve;
}

//全主元高斯法
uint8 b_solve8x8_Ax_b(float AB_input[8][9], float X[8])
{
    float AB[8][9];
        for(uint8 loop = 0;loop < 8;loop++)
        {
            for(uint8 inter = 0;inter < 9;inter++)
            {
                AB[loop][inter] = AB_input[loop][inter];
            }
        }
	// AX = B
	// 矩阵赋值[行][列]
	uint8 Row_MainElementChange_Temp[8] = { 0, 1, 2, 3, 4, 5, 6, 7 };//列主元保留交换特性//与列变换同时进行 
	//float AB[8][9];
        /*
	for (uint16 lineNum = 0; lineNum < 8; lineNum++)
	{
		for (uint8 RowCtr = 0; RowCtr < 8; RowCtr++)
		{
			AB[lineNum][RowCtr] = A[lineNum][RowCtr];
		}
	}
	for (uint8 ExRow_LineCtr = 0; ExRow_LineCtr<8; ExRow_LineCtr++)
	{
		AB[ExRow_LineCtr][8] = B[ExRow_LineCtr];
	}
        */
	//========================================================================//
	//以下为初等行变换 
	uint8 Line_BeWithRowChange = 0;//AB矩阵的秩//非0，列变行变，列变行不变 
	uint8 Row_Ctr = 0;//列计数 
	for (Row_Ctr = 0; Row_Ctr < 9; Row_Ctr++)//选取每列，目标就是消去此列所有元素或只剩下一个1//依赖行信息 
	{
		//====================================================================//
		//秩确认 
		if (8 == Row_Ctr)//确认AB矩阵秩是否满秩 
		{
			if (8 == Line_BeWithRowChange)
			{
				//cout << "满秩" << endl;
			}
			else
			{
				//cout << "不满秩" <<endl;//return 'F';//非满秩 
                                return 'F';
			}
			break;//满秩 
		}
		//====================================================================//
		//求解方程组 
		do//获取本行信息//换取全主元消去法 
		{
			//获取最大值信息 
			uint8 Max_Num_Line_address = Line_BeWithRowChange;//认定此时数值最大
			uint8 Max_Num_Row_address = Row_Ctr;
			float Max_Num_Var = __F_ABS(AB[Line_BeWithRowChange][Row_Ctr]);//最大值 
			for (uint8 Line_ForFindMax_loop = Max_Num_Line_address; Line_ForFindMax_loop < 8; Line_ForFindMax_loop++)
			{
				for (uint8 Row_ForFindMax_loop = Max_Num_Row_address; Row_ForFindMax_loop<8; Row_ForFindMax_loop++)
				{
					if ((__F_ABS(AB[Line_ForFindMax_loop][Row_ForFindMax_loop])) > Max_Num_Var)
					{
						Max_Num_Var = __F_ABS(AB[Line_ForFindMax_loop][Row_ForFindMax_loop]);//最大值赋值
						Max_Num_Line_address = Line_ForFindMax_loop;//行赋值 
						Max_Num_Row_address = Row_ForFindMax_loop;//列赋值 
					}
				}
			}
			//行列交换 
			if ((0.0 != Max_Num_Var) && (Line_BeWithRowChange != Max_Num_Line_address) && (Row_Ctr != Max_Num_Row_address))//同列各行最大值确定非零 
			{
				//行变换
				float lineRow_tempForChange = 0.0;
				for (uint8 loop = 0; loop < 9; loop++)//行交换 
				{
					lineRow_tempForChange = AB[Line_BeWithRowChange][loop];
					AB[Line_BeWithRowChange][loop] = AB[Max_Num_Line_address][loop];
					AB[Max_Num_Line_address][loop] = lineRow_tempForChange;
				}
				//列变换 
				for (uint8 loop = 0; loop < 8; loop++)
				{
					//列交换 
					lineRow_tempForChange = AB[loop][Row_Ctr];
					AB[loop][Row_Ctr] = AB[loop][Max_Num_Row_address];
					AB[loop][Max_Num_Row_address] = lineRow_tempForChange;
					//参数变换
				}
				uint8 changeFloatTemp = 0;
				changeFloatTemp = Row_MainElementChange_Temp[Row_Ctr];//Row_Ctr有可能不等于 Row_MainElementChange_Temp[Row_Ctr]
				Row_MainElementChange_Temp[Row_Ctr] = Row_MainElementChange_Temp[Max_Num_Row_address];
				Row_MainElementChange_Temp[Max_Num_Row_address] = changeFloatTemp;
			}
		} while (0);
		//
		if (0.0 != AB[Line_BeWithRowChange][Row_Ctr])//本次元素是否为0
		{
			//本行以外信息 （下次从此更新）//行信息继承、列信息继承
			float self_Line_GaiaNum = AB[Line_BeWithRowChange][Row_Ctr];//选取本行归一化数值
			for (uint8 self_Line_RowCtr = Row_Ctr; self_Line_RowCtr < 9; self_Line_RowCtr++)
			{
				AB[Line_BeWithRowChange][self_Line_RowCtr] = AB[Line_BeWithRowChange][self_Line_RowCtr] / self_Line_GaiaNum;//本行归一化
			}
			for (uint8 Cal_Line_Ctr = Line_BeWithRowChange + 1; Cal_Line_Ctr < 8; Cal_Line_Ctr++)//行增广，列起始点与行同向
			{
				//主元素不为0，消去本行所有元素
				//删除本行外其余行的数值
				float Die_SammLikeGaiaLinesRow = AB[Cal_Line_Ctr][Row_Ctr] / AB[Line_BeWithRowChange][Row_Ctr];//获取消除增益
				//cout << "Die_SammLikeGaiaLinesRow" << Die_SammLikeGaiaLinesRow << endl;//用于测试 
				//*****************************************************************************//
				for (uint8 ExLine_RowNumCtr = Row_Ctr; ExLine_RowNumCtr < 9; ExLine_RowNumCtr++)//从目标原始行开始，每行固定消去
				{
					AB[Cal_Line_Ctr][ExLine_RowNumCtr] = AB[Cal_Line_Ctr][ExLine_RowNumCtr] - //行固定，列增广
						Die_SammLikeGaiaLinesRow * AB[Line_BeWithRowChange][ExLine_RowNumCtr];//
					//参数描述
				}//****************************************************************************//
			}
			Line_BeWithRowChange++;//与列变换同行 			
		}//else//{//为0则忽略本次 //}
	}//=======================================================================//
	//回代计算//满秩时候可得最优解
	/*
	cout << endl;
	for (uint8 loop = 0; loop < 8; loop++)
	{
		for (uint8 row_loop = 0; row_loop < 9; row_loop++)
		{
			cout << AB[loop][row_loop] << " ";
		}
		cout << endl;
		cout << endl;
		cout << endl;
		//cout << X[Row_MainElementChange_Temp[loop]] << endl;//loop行所在信息即 Row_MainElementChange_Temp[loop]应存储信息 
	}
	*/

	//cout << "秩" << (float)Line_BeWithRowChange << endl;
	Line_BeWithRowChange -= 1;//秩为行秩，满秩的时候数值为8，故必须删去一个数值//求取秩所在的行坐标
	for (sint8 LineCtr_Cyclotron = Line_BeWithRowChange; LineCtr_Cyclotron >= 0; LineCtr_Cyclotron--)//从秩开始，逐步向上减去
	{
		//break;
		uint8 LineMaxFinder_UpperNum = 8;//总共选有行//计数用//可以将每行起始位置赋值给此数，不过这样就要求这个得跳出这个循环
		uint8 EachLine_StarRowNum = 0;//初始化失误：Line_BeWithRowChange - 1;2015.2.8
		while (LineMaxFinder_UpperNum)//获取所在行的纵坐标//满秩时将不服从主阵
		{
			if (0.0 != AB[LineCtr_Cyclotron][EachLine_StarRowNum])//此步为的是获取需要减去行的首有数值的数据 
			{
				break;
			}
			EachLine_StarRowNum++;
			LineMaxFinder_UpperNum--;
		}
		//cout <<"EachLine_StarRowNum"<<(float)EachLine_StarRowNum<<endl;//测试用 
		//cout << "LineMaxFinder_UpperNum" <<(float)LineMaxFinder_UpperNum<<endl;
		if (0 != LineMaxFinder_UpperNum)//为搜寻到最后一行
		{
			//EachLine_StarRowNum为本行起始位置
			//先行减，后移动列
			for (uint8 Line_Ctr = 0; Line_Ctr < LineCtr_Cyclotron; Line_Ctr++)//从RowCtr到LineCtr_Cyclotron所在行
			{
				float Die_ForLine = AB[Line_Ctr][EachLine_StarRowNum] / AB[LineCtr_Cyclotron][EachLine_StarRowNum];//先求取截去增益

				//cout << "Die_ForLine" << Die_ForLine <<endl;
				for (uint8 RowCtr_ForChace = EachLine_StarRowNum; RowCtr_ForChace < 9; RowCtr_ForChace++)//为回代计数
				{
					AB[Line_Ctr][RowCtr_ForChace] = AB[Line_Ctr][RowCtr_ForChace] - Die_ForLine * AB[LineCtr_Cyclotron][RowCtr_ForChace];
				}
			}
		}
	}
	//========================================================================//
	//存入X中 => 最后的元素 
	for (uint8 loop = 0; loop < 8; loop++)
	{
		X[Row_MainElementChange_Temp[loop]] = AB[loop][8];//loop行所在信息即 Row_MainElementChange_Temp[loop]应存储信息 
	}
	//Line_BeWithRowChange => 行秩 
	/*
	cout << endl;
	for (uint8 loop = 0; loop < 8; loop++)
	{
		for (uint8 row_loop = 0; row_loop < 9; row_loop++)
		{
			cout << AB[loop][row_loop] << " ";
		}
		cout << endl;
		cout << endl;
		cout << endl;
		//cout << X[Row_MainElementChange_Temp[loop]] << endl;//loop行所在信息即 Row_MainElementChange_Temp[loop]应存储信息 
	}
	*/

	return 'T';
}


//============================================================================//
//载入控制参数
void v_LoadingControlPara(s_Control* temp_Control,s_ImageAbstract* ImageAbstract)
{
    temp_Control->image_ratio[0] = 0.231959;//0.214521;
    temp_Control->image_ratio[1] = -0.31787;//-0.313531;
    temp_Control->image_ratio[2] = 4.51032;//6.10561;
    temp_Control->image_ratio[3] = -2.98023e-8;//1.49012e-8;
    temp_Control->image_ratio[4] = 0.635739;//0.41254;
    temp_Control->image_ratio[5] = -6.23711;//2.37625;
    temp_Control->image_ratio[6] = -1.62981e-9;//1.28057e-9;
    temp_Control->image_ratio[7] = -0.0137457;//-0.0132013;
    
    ImageAbstract->LastFrame_CentralPos = 185/2;
}


void v_ImageCut()//图像信息处理//selfjudge_SendMessage=>
{
    	/*
	其实我想要得到的只是合适的宽度，以及起点以及终点。起点已知，而终点未知。=>可以设定合适的边界定义所在合适区域的终值。
	故至此为止。可以得到框架信息作为合适的边界值的获取。
	故所有的任务就是找到最适下降沿，在此之前的边沿均可忽略。=>可以消除反光造成的误判，以及身处黑线时的情况。
	然后得到最后的区域，存在可以延展的区域，然后就是用SA2015优化的过程。
	奥卡姆剃刀。The Razor。
  
        selfjudge_SendMessage => 输入参数
	*/
//	CString Show;
//	CString SendCrossHeight = "结束";
//	CString * LineCenterCondition;
//	LineCenterCondition = new CString[m_height];
//	for (uint16 loop = 0; loop < m_height; loop++)
//	{
//		LineCenterCondition[loop] = "";
//	}
//	::SendMessage(m_owner, WM_Clear_Trk_Text, 0, 0);
	//float f_width_ratio[2] = { 0, 0 };//x = (30*h/2)*y + 30/a//绝对宽度系数 x = (30*a)/(Y*h + 1)
    //uint8 JumpOK_flag = 0;
    uint8 JumpOK_flag_counter = 0;
    uint8 JumpVarOK_first = 0;
    //========================================================================//
    //常数设置
    const uint16 constNum_X_MaxCounter = 184;//=>消除最后一个零点情况
    const uint16 constNum_Line_MaxCounter = 60;//
    const uint16 constn_xFindJumpLine_Width = 3;//横向跨线//固定值
    //========================================================================//
    //
    struct ___vaild_heightInterval//高度的最佳有效区域
    {
	uint8 n_lastEnd_Y;// = m_height;//最终的Y数值 => 可以由绝对宽度定 => 但可以由break跳出循环结束
	uint8 n_firstStart_Y;// = 0;//初始值
    }vaild_heightInterval;
    vaild_heightInterval.n_firstStart_Y = 0;
    vaild_heightInterval.n_lastEnd_Y = constNum_Line_MaxCounter;
	//图像连续性必须保证
	//m_MatMapMainBodyArray;//原图像信息
	//=================================================//
    
	//=================================================//
	//全部模型系数
    typedef 
    struct//图像绝对数据框架
    {
	float f_width_ratio[2];//宽度变化率
	float f_TrkOneBlackPoint[2];//单点信息
	float f_depth_ratio[5];//向前等量宽度对应的长度信息
    }s_Frame_Trk;
    s_Frame_Trk Frame_Trk;
    do//框架赋值//认定30为标准框架
    {
	float a = m_Control.image_ratio[0];
	float b = m_Control.image_ratio[1];
	float c = m_Control.image_ratio[2];
        float d = m_Control.image_ratio[3];
	float e = m_Control.image_ratio[4];
	float f = m_Control.image_ratio[5];
	float g = m_Control.image_ratio[6];
	float h = m_Control.image_ratio[7];
	//float f_width_ratio[2];//x = (30*h/a)*y + 30/a//绝对宽度系数
	Frame_Trk.f_width_ratio[1] = 30.f * h / a;
	Frame_Trk.f_width_ratio[0] = 30.f / a;
	//float f_TrkOneBlackPoint[2];//x = (3.5*h/a)*y + 3.5/a => 黑点宽//3cm边界宽时使用
	Frame_Trk.f_TrkOneBlackPoint[1] = 2.f * h / a;
	Frame_Trk.f_TrkOneBlackPoint[0] = 2.f / a;
	//float son = -30 * h*h * y*y - 60 * h*y - 30;//float mother = (30 * h*h)*y + 30 * h - e + f*h;
	Frame_Trk.f_depth_ratio[0] = -30.f * h * h;//y*y
	Frame_Trk.f_depth_ratio[1] = -60.f * h;//y
	Frame_Trk.f_depth_ratio[2] = -30.f;//1

	Frame_Trk.f_depth_ratio[3] = 30.f * h * h;//y
	Frame_Trk.f_depth_ratio[4] = (30.f + f)*h - e;//1
    } while (0);
    //========================================================================//
    //========================================================================//
    //========================================================================//
    //========================================================================//
    //========================================================================//
    uint16 perLine_vaild_width = constNum_X_MaxCounter;// - 1;//185-1//一行有效宽度
    //========================================================================//
    sint16 lostDouble_UpestHeight = 0;//丢双边计数最大值
    uint8 lostDouble_TimerCounter = 0;//双边计时器
    uint8 lostDouble_AllCounter = 0;
    typedef
    struct
    {
        uint8 Flag;// = 0;
        uint8 Gaia_X;// = 0;
        uint8 Gaia_Y;// = 0;
    }s_DrawLostDouble;
    s_DrawLostDouble DrawLostDouble;
    DrawLostDouble.Flag = 0;
    DrawLostDouble.Gaia_X = 0;
    DrawLostDouble.Gaia_Y = 0;
//	//=================================================//
//	uint16 perLine_vaild_width = m_width - 1;//绝对宽度下的存在的合乎理性的宽度
//	uint16 absolute_vaild_width = m_width - 1;//绝对宽度
//	uint16 perLine_all_width = m_width - 1;//广义宽度
//	sint16 Sideabsolute_TrkSideLineWide = 0;//边线宽
//	//=================================================//
//	//uint8 lineCenterFindPos_Lost_Counter = 0;//中线丢双边次数
//	//uint16 lineCenterFindPos_Lost_Counter_CrossYheight_Ypos = 0;//丢边初始时认定的最长丢边长度 => 即一个赛道宽的长度
//	//uint8 OnBlackAreaTimer_Counter = 0;
//    sint16 x_leftLimitNum = 0;//Left最大限制
//    sint16 x_rightLimitNum = m_width;//Right最大限制

    uint16 x_startPos = m_ImageAbstract.LastFrame_CentralPos;//x轴起始位置，取值范围为0 - m_width//即中线所在位置
    sint16 x_startPos_n_add_one = m_ImageAbstract.LastFrame_CentralPos;//x(n+1)

//    uint16 x_witdhViewed = 0;//被看到的赛道宽度
//	//x_startPos = this->m_width / 2;//一般情况下，第一块多米诺选择为中线一半，或者上次某值的信息//后者需要再次考虑

    //========================================================================//
    //========================================================================//
    //由跳变决定的边沿位置
    typedef
    struct//边沿数据情况
    {
	uint8 n_right_end;//Right截止下降沿
	uint8 n_left_end;//Left截止下降沿
	uint8 n_right_banDone;//Right侧出现上升沿
	uint8 n_left_banDone;//Left侧出现上升沿
    }s_number_Trk;
    s_number_Trk number_Trk;//数值信号
    number_Trk.n_left_banDone = 0;
    number_Trk.n_right_banDone = 0;
    number_Trk.n_left_end = 0;
    number_Trk.n_right_end = 0;
    //========================================================================//
    //========================================================================//
    typedef
    struct
    {
	uint8 leftSide_isDown;//是否有效边沿
	uint8 rightSide_isDown;
        
	uint8 leftSide_isUp;//上升沿是否存在
	uint8 rightSide_isUp;
    }s_LogicCondition;//逻辑信号结构体
    s_LogicCondition LogicCondition;//逻辑信息存在
    LogicCondition.leftSide_isDown = 0;
    LogicCondition.leftSide_isUp = 0;
    LogicCondition.rightSide_isDown = 0;
    LogicCondition.rightSide_isUp = 0;
    
    
	//以下为信息值
    uint16 perLine_JumpNumVaild = 0;//跳变阈值//一行大于此数值时，跳变可以认定为合理
    uint16 perLine_JumpNumNonVaild = 0;//跳变无效值//一行小于此数值时，跳变认为为不合理
	//理论来说，赛道在范围内越多，此数值越合理。
	//而第一次获取跳变仍是不可知情形

	
	//=>故有一种思路，获取所有合理跳变数值，然后进行连续性判定
	//若连续性判定合理，则认定为合适的点或边
	//具体操作时，可以暂存另一数组，然后将情形填入

	//===================================================//
	//进入处理部分
	//前部处理函数
    //=>有效高度区间设定
    vaild_heightInterval.n_firstStart_Y = 0;//
    vaild_heightInterval.n_lastEnd_Y = constNum_Line_MaxCounter;//行数计时
    //
    do//首尾确认//vaild_heightInterval
    {
	for (uint16 loop = 0; loop < constNum_Line_MaxCounter; loop++)//遍历全部宽度
	{
            if (Frame_Trk.f_width_ratio[1] * loop + Frame_Trk.f_width_ratio[0] >= constNum_X_MaxCounter)//获取最近点
            {
                vaild_heightInterval.n_firstStart_Y = loop;//获取最近
            }
            if (Frame_Trk.f_TrkOneBlackPoint[1] * loop + Frame_Trk.f_TrkOneBlackPoint[0] <= 1)
            {
		vaild_heightInterval.n_lastEnd_Y = loop;//获取最远
		break;//结束
            }
	}
    } while (0);
    m_ImageAbstract.Start_Y_Position = vaild_heightInterval.n_firstStart_Y;
    //========================================================================//
    //========================================================================//
    //========================================================================//
    x_startPos = m_ImageAbstract.LastFrame_CentralPos;//将上次中值继承于本次 => 上一场的中值继承
    //========================================================================//
    //========================================================================//
    //========================================================================//
//	x_startPos = m_width / 2;//初始赋值
    sint16 process_find_timer = -1;//进程搜寻时间
    //=====================================================================================================//
    //进入判断环节
    // Number全部初始化
    uint8 lr_n_cut_1_isExist = 3;//左右是否存在标志3=>不存在，0边1边2边
    
    m_Control.need_TurnLeft = 0;
    m_Control.need_TurnRight = 0;
    m_Control.need_Hold = 0;
    //=====================================================================================================//
    uint8 end_y_ctr = vaild_heightInterval.n_lastEnd_Y;//提前赋值给最终可能情况
    for (uint8 y_ctr = vaild_heightInterval.n_firstStart_Y;
                y_ctr < vaild_heightInterval.n_lastEnd_Y;
                y_ctr++)//数值循环判定=>基本最早环节为185点以内，且最外处的宽度应小于 constn_xFindJumpLine_Width
    {
        //m_ImageAbstract.Central[y_ctr] = x_startPos_n_add_one;
        number_Trk.n_left_end = 255;
        number_Trk.n_right_end = 255;
        //程序进行时间=============================================//
	process_find_timer++;//搜寻次数判定=>防止因为代码次序导致的失控
        //
	perLine_vaild_width = (uint16)(Frame_Trk.f_width_ratio[1] * (float)y_ctr + Frame_Trk.f_width_ratio[0]);//有效行的赛道有效宽
	m_ImageAbstract.width[y_ctr] = perLine_vaild_width;
        
        //目标会一直寻找到下降沿或者寻找失败
        
        do//获取每行的信息
	{
            uint8 perline_aver_pixelNumber = 0;
            uint8 perline_jump_max2min = 0;

            uint32 AllPixel_Counter = 0;
            uint8 maxPixel = 0;
            uint8 minPixel = 255;
            
            uint8 BookLineNumber = 0;//记录的行数
            
            for (uint16 loop = 0; loop < constNum_X_MaxCounter; loop++)
            {//
                
                if(0 != m_ImageBeholder_Data[y_ctr][loop])
                {
                //    static uint8 x_recorder = 0;
                //    static uint8 y_recorder = 0;
                    BookLineNumber ++;
                    AllPixel_Counter += m_ImageBeholder_Data[y_ctr][loop];
                    
                    if (m_ImageBeholder_Data[y_ctr][loop] > maxPixel){ maxPixel = m_ImageBeholder_Data[y_ctr][loop]; }
                    if (m_ImageBeholder_Data[y_ctr][loop] < minPixel){ minPixel = m_ImageBeholder_Data[y_ctr][loop]; }
                }
                
            }
			//====//
            perline_aver_pixelNumber = AllPixel_Counter / BookLineNumber;//均值
            perline_jump_max2min = maxPixel - minPixel;//差值

            perLine_JumpNumVaild = (uint8)((float)perline_jump_max2min * 0.4f);
            perLine_JumpNumNonVaild = (perline_aver_pixelNumber / 4);

	} while (0);//特征提取完毕
        
        do//寻找左右线
	{
            //======宽度匹配==================================================//
            uint16 n_find_half_mutlwidth = (uint16)((perLine_vaild_width * 1.25f)/2.f);//半绝对宽度乘以合理偏置=>分配给理论数值
            sint16 x_rightLimitNum = x_startPos + n_find_half_mutlwidth;//右侧距离
            sint16 x_leftLimitNum = x_startPos - n_find_half_mutlwidth;//左侧距离//理论合理限制
			
            uint16 tempx_rightLimitNum = x_rightLimitNum;
            if (x_rightLimitNum > constNum_X_MaxCounter - constn_xFindJumpLine_Width)
            { tempx_rightLimitNum = constNum_X_MaxCounter - constn_xFindJumpLine_Width; }//幅度限制

            uint16 tempx_leftLimitNum = x_leftLimitNum;
            if (x_leftLimitNum < constn_xFindJumpLine_Width){ tempx_leftLimitNum = constn_xFindJumpLine_Width; }//幅度限制
			
            if(process_find_timer <= 3)//3啊！
            {//更改前六行
                tempx_leftLimitNum = constn_xFindJumpLine_Width + constn_xFindJumpLine_Width;
                tempx_rightLimitNum = constNum_X_MaxCounter - constn_xFindJumpLine_Width - constn_xFindJumpLine_Width;
            }
            //======右线是否存在==============================================//
            LogicCondition.rightSide_isUp = 0;//是否存在上升沿
            LogicCondition.rightSide_isDown = 0;//是否存在有效边沿
            for (sint16 LINE_CTR = x_startPos;
                        LINE_CTR + constn_xFindJumpLine_Width < tempx_rightLimitNum; 
                        LINE_CTR++)//向右提线
            {
		sint16 n_jumpVar = m_ImageBeholder_Data[y_ctr][LINE_CTR] - m_ImageBeholder_Data[y_ctr][LINE_CTR + constn_xFindJumpLine_Width];
                sint16 absn_jumpVar = __ABS(n_jumpVar);

		if ((absn_jumpVar > perLine_JumpNumVaild)
                 && (absn_jumpVar > perLine_JumpNumNonVaild))
                {
                    if (n_jumpVar > 0)//下降沿
                    {
			number_Trk.n_right_end = LINE_CTR;
			LogicCondition.rightSide_isDown = 1;
			break;//跳出本循环
                    }
                    else//上升沿
                    {
                        number_Trk.n_right_banDone = LINE_CTR;
                        LogicCondition.rightSide_isUp = 1;
                    }
                }
            }//右线搜寻完毕
            //======左线是否存在================================================================//
            LogicCondition.leftSide_isUp = 0;
            LogicCondition.leftSide_isDown = 0;
            for (sint16 LINE_CTR = x_startPos; 
                        LINE_CTR - constn_xFindJumpLine_Width >= tempx_leftLimitNum; 
                        LINE_CTR--)
            {
                sint16 n_jumpVar = m_ImageBeholder_Data[y_ctr][LINE_CTR] - m_ImageBeholder_Data[y_ctr][LINE_CTR - constn_xFindJumpLine_Width];
		sint16 absn_jumpVar = __ABS(n_jumpVar);

		if ((absn_jumpVar > perLine_JumpNumVaild)
		 && (absn_jumpVar > perLine_JumpNumNonVaild))
		{
                    if (n_jumpVar > 0)//下降沿
                    {
			number_Trk.n_left_end = LINE_CTR;
			LogicCondition.leftSide_isDown = 1;
			break;//跳出本循环
                    }
                    else//广义宽度
                    {
			number_Trk.n_left_banDone = LINE_CTR;
			LogicCondition.leftSide_isUp = 1;
                    }
                }
            }//左线搜寻完毕
        } while (0);//左右线寻找完毕
        
        //====================================================================//
        //====================================================================//
        //====================================================================//
        //====================================================================//
        //====================================================================//
        //信息综合与机器学习效果所在区域
	if (2 == LogicCondition.leftSide_isDown + LogicCondition.rightSide_isDown)
	{//双边都存在，有时候这是最重要的代码
            if(2 == DrawLostDouble.Flag)//判断是否需要补线
            {
                DrawLostDouble.Flag = 1;//确实需要补线
            }
            lostDouble_TimerCounter = 0;//丢线寄存器清空
            x_startPos_n_add_one = (number_Trk.n_left_end + number_Trk.n_right_end) / 2;//获取中心值位置
            
            uint8 now_width = number_Trk.n_right_end - number_Trk.n_left_end;
            //当此次宽度小于应该宽度的 1 / 4，即认为出现了错误
            //障碍=>斜入长黑线障碍与楔形路障错误的地方
            if(now_width * 4 <= m_ImageAbstract.width[y_ctr])//此次即认定为合适的
            {//至此，我们应该选择一个很好的方式去忽略相应的黑色区域
                //我们是否应该多次循迹还是说找个更方便的方法
                //如果是左拐，我们应该继续左拐<=长斜入黑线障碍
                //如果是左拐，我们应该更左拐？=>是否导致强烈的拐弯？<=楔形路障
                //简单的方法=>继续相应寻线=>真实蛋疼的故事=>根据当前宽度进行匹配
                do//进行多余的循迹
                {
                    uint8 left_pluto_Pos = 255;
                    for (sint16 LINE_CTR = number_Trk.n_left_end;//此步为寻找左线
                        LINE_CTR - constn_xFindJumpLine_Width >= constn_xFindJumpLine_Width;//限制幅度为最左
                        LINE_CTR--)
                    {
                        sint16 n_jumpVar = m_ImageBeholder_Data[y_ctr][LINE_CTR]//获取合适的跳变值
                                         - m_ImageBeholder_Data[y_ctr][LINE_CTR - constn_xFindJumpLine_Width];
                        sint16 absn_jumpVar = __ABS(n_jumpVar);//获取绝对值
                        if ((absn_jumpVar > perLine_JumpNumVaild) && (absn_jumpVar > perLine_JumpNumNonVaild)
                        && (n_jumpVar > 0)){left_pluto_Pos = LINE_CTR;break;}//=>寻找到下一个边沿
                    }//左线搜寻完毕
                    uint8 right_pluto_Pos = 255;
                    for (sint16 LINE_CTR = number_Trk.n_right_end;//此步为寻找右线
                        LINE_CTR + constn_xFindJumpLine_Width < constNum_X_MaxCounter - constn_xFindJumpLine_Width;//限制幅度为最右
                        LINE_CTR++)//向右提线
                    {
                        sint16 n_jumpVar = m_ImageBeholder_Data[y_ctr][LINE_CTR]//获取合适的跳变值
                                         - m_ImageBeholder_Data[y_ctr][LINE_CTR + constn_xFindJumpLine_Width];
                        sint16 absn_jumpVar = __ABS(n_jumpVar);//获取绝对值
                        if ((absn_jumpVar > perLine_JumpNumVaild) && (absn_jumpVar > perLine_JumpNumNonVaild)
                         && (n_jumpVar > 0)){right_pluto_Pos = LINE_CTR;break;}//跳出本循环
                    }//右线搜寻完毕
                    
                    uint8 Pos_Side[4] = {255,255,255,255};//边沿处理。
                    Pos_Side[0] = left_pluto_Pos;
                    Pos_Side[1] = number_Trk.n_left_end;
                    Pos_Side[2] = number_Trk.n_right_end;
                    Pos_Side[3] = right_pluto_Pos;
                    
                    if(255 != Pos_Side[0]){;}
                    
                }while(0);
                
            }
        
        
            lr_n_cut_1_isExist = 2;//
            //可能有坡道情况//障碍情况(粗边与短边)//以及进入回弯的回来部分
            /*----可进行美观上的补线----*/
	}
	else
	{
            if ((1 == LogicCondition.leftSide_isDown) || (1 == LogicCondition.rightSide_isDown))
            {
                lostDouble_TimerCounter = 0;//丢线寄存器清空
		if (1 == LogicCondition.leftSide_isDown)//左边界有效
		{
                    x_startPos_n_add_one = (sint16)(number_Trk.n_left_end + perLine_vaild_width*0.45f);//相当于补边
                    if((x_startPos_n_add_one < x_startPos)&&(process_find_timer > 1))//本次数值在上次数值的左边
                    {
                        x_startPos_n_add_one = m_ImageAbstract.Central[y_ctr-1]//路径的PD作用
                                            + (m_ImageAbstract.Central[y_ctr-2]-m_ImageAbstract.Central[y_ctr-3]);
                    }
                }
                else//右边界有效
		{
                    x_startPos_n_add_one = (sint16)(number_Trk.n_right_end - perLine_vaild_width*0.45f);//相当于补边
                    if((x_startPos_n_add_one > x_startPos)&&(process_find_timer > 1))//本次数值在上次数值的右边
                    {
                        x_startPos_n_add_one = m_ImageAbstract.Central[y_ctr-1] 
                                            + (m_ImageAbstract.Central[y_ctr-2]-m_ImageAbstract.Central[y_ctr-3]);
                    }
                }
                lr_n_cut_1_isExist = 1;//存在一条边
                /*----上次两边都有的话----*/
                
            }
            else//全丢边
            {
                if(0 == DrawLostDouble.Flag)
                {
                    DrawLostDouble.Flag = 2;
                    DrawLostDouble.Gaia_X = x_startPos_n_add_one;
                    DrawLostDouble.Gaia_Y = y_ctr;
                }
                //DrawLostDouble.Flag = 2;//绘画模式
                lostDouble_TimerCounter++;//丢线计数
                lostDouble_AllCounter++;//丢线整体计数
                if(1 == lostDouble_TimerCounter)
                {//第一次双边都丢失记录下此刻若是十字的话，线应该走多远
                    float son = Frame_Trk.f_depth_ratio[0] * y_ctr*y_ctr + Frame_Trk.f_depth_ratio[1] * y_ctr + Frame_Trk.f_depth_ratio[2];
                    float mother = Frame_Trk.f_depth_ratio[3] * y_ctr + Frame_Trk.f_depth_ratio[4];
                    lostDouble_UpestHeight = (sint16)(son / mother + constn_xFindJumpLine_Width);//向前行走最大值
                    
                    
                }                
                
                
                x_startPos_n_add_one = x_startPos;//将上次数值给当前数值//可以用最小二乘，但运算复杂
                
                if(process_find_timer > 3)//前馈补偿=>下三次才会生效
                {
                    x_startPos_n_add_one = m_ImageAbstract.Central[y_ctr-1] + 
                                         ((m_ImageAbstract.Central[y_ctr-1] - m_ImageAbstract.Central[y_ctr-2])
                                         +(m_ImageAbstract.Central[y_ctr-2] - m_ImageAbstract.Central[y_ctr-3]))/2;
                }
                
                /*以下是斜入十字摆正姿态时使用*/
                /*
                static sint8 change_ratio = 0;
                if((3 == process_find_timer)&&(lostDouble_AllCounter >= 2))//当近几行全是全白的时候
                {//黑线跟随
                    //首先，进入直角=>但是直角不会特意丢一边
                  //其次为斜入十字//以下数值最好根据实际的情况处理5.7.14:15
                    m_ImageAbstract.Central[y_ctr] = m_ImageAbstract.LastFrame_CentralPos;
                    m_ImageAbstract.Central[y_ctr - 1] = m_ImageAbstract.LastFrame_CentralPos + change_ratio;
                    m_ImageAbstract.Central[y_ctr - 2] = m_ImageAbstract.LastFrame_CentralPos + change_ratio;
                    m_ImageAbstract.Central[y_ctr - 3] = m_ImageAbstract.LastFrame_CentralPos + change_ratio + change_ratio;
                }//全白时候摆正角度完毕

                if(1 == lr_n_cut_1_isExist)//如若上次丢一边
                {
                    change_ratio = (x_startPos_n_add_one - m_ImageAbstract.Central[y_ctr-1]);
                    m_ImageAbstract.Central[y_ctr-1] = 
                                            x_startPos_n_add_one + //更改
                                           change_ratio;
                }
                */
                
                
                lr_n_cut_1_isExist = 0;//这个必须在此代码的末尾
            }//处理无边线情况的代码
	}//到目前为止，下降沿的信息识别全部完毕        
        
        if(x_startPos_n_add_one > constNum_X_MaxCounter - constn_xFindJumpLine_Width * 2)
        {x_startPos_n_add_one = constNum_X_MaxCounter - constn_xFindJumpLine_Width * 2;}//限幅抑制信息
        if(x_startPos_n_add_one < constn_xFindJumpLine_Width * 2)
        {x_startPos_n_add_one = constn_xFindJumpLine_Width * 2;}
        
        do
        {
            //break;//跳出绘画的流程
            if(1 == DrawLostDouble.Flag)
            {
                DrawLostDouble.Flag = 0;
                float w = 0.f;
                w = ((float)(x_startPos_n_add_one - DrawLostDouble.Gaia_X))
                  / ((float)(y_ctr - DrawLostDouble.Gaia_Y));
                uint32 X_set = x_startPos_n_add_one;
                float dw = 0.f;
                for(uint8 loop = y_ctr;loop > DrawLostDouble.Gaia_Y;loop--)
                {
                    m_ImageAbstract.Central[loop] = (uint8)(X_set - dw);
                    dw = dw + w;//补充
                }
            }
        }while(0);//至此补线过程结束

        
        /*----以上四行为限制幅度----*/
        
        if(process_find_timer >= 2)//判断跳出标志位
        {
          if(0 == JumpVarOK_first){JumpVarOK_first = m_ImageBeholder_Data[y_ctr - 1][m_ImageAbstract.Central[y_ctr - 1]];}
            sint16 JumpVar = m_ImageBeholder_Data[y_ctr][x_startPos_n_add_one] - 
                             JumpVarOK_first;
            sint16 abs_JumpVar = __ABS(JumpVar);
            if ((abs_JumpVar > perLine_JumpNumVaild)
             && (abs_JumpVar > perLine_JumpNumNonVaild))
            {
                if (JumpVar < 0)//下降沿//黑减白<0
                {
                    JumpOK_flag_counter++;
                    if(3 == JumpOK_flag_counter)
                    {
                        end_y_ctr = y_ctr - 3;
                        break;
                    }
                }
            }
        }
        
        
        /*----------------------------*/
        //根据中点跳变情况
        /*----------------------------*/
        //以下为判定左中右线
        
        m_ImageAbstract.Central[y_ctr] = x_startPos_n_add_one;
        m_ImageAbstract.Left[y_ctr] = number_Trk.n_left_end;//丢线即为255
        m_ImageAbstract.Right[y_ctr] = number_Trk.n_right_end;
        
        do//=>一起确定
        {
            uint8 Central_n_cut_1 = 0;
            uint8 Left_n_cut_1 = 0;
            uint8 Right_n_cut_1 = 0;
            
            if(process_find_timer > 0)//以下六行代码主要为了确定上次的信息
            {
                Central_n_cut_1 = m_ImageAbstract.Central[y_ctr - 1];
                Left_n_cut_1 = m_ImageAbstract.Left[y_ctr - 1];
                Right_n_cut_1 = m_ImageAbstract.Right[y_ctr - 1];
            }
            else
            {
                Central_n_cut_1 = m_ImageAbstract.LastFrame_CentralPos;
                Left_n_cut_1 = m_ImageAbstract.LastFrame_LeftPos;
                Right_n_cut_1 = m_ImageAbstract.LastFrame_RightPos;
            }
            /*------------------------------------------------------------------
            //单线判断
            中线(n)是不是在中线(n-1)
            --------------------------------------------------------------------
            */
            
        }while(0);
        
        //接下来即根据上次信息来断定本次的左中右三线数值的位置=>其实是判断本次中线
        
        
        do//Judge The Side Where is
        {//此代码破单线时再写=>可能会出无数问题
        }while(0);
        end_y_ctr = y_ctr;//每次都更新

           
        x_startPos = x_startPos_n_add_one;//中线继承
    }//单次结束
    m_ImageAbstract.Last_Y_Position = end_y_ctr;//赋值最后
    
    
    /*
    if(__ABS(process_find_timer - lostDouble_AllCounter) <= 1)
    {
        m_Control.need_Hold = 1;
    }
    */
    /*
    if(all_height_Y_last_cut_first < 20)//小于此时将进入判定
    {
        uint8 last = (all_height_Y_last_cut_first > 30)?30:all_height_Y_last_cut_first;
        uint8 left_counter = 0;
        uint8 right_counter = 0;
        for(uint8 loop = m_ImageAbstract.Start_Y_Position;//整体循环
                  loop < last + m_ImageAbstract.Start_Y_Position;
                  loop ++)
        {
            if(255 == m_ImageAbstract.Left[loop]){left_counter++;}
            if(255 == m_ImageAbstract.Right[loop]){right_counter++;}
        }
        if(((left_counter > all_height_Y_last_cut_first/2)
          &&(right_counter > all_height_Y_last_cut_first/2))
         ||(all_height_Y_last_cut_first < 10))
        {
            m_Control.need_Hold = 1;
        }
        else
        {
            
            if(left_counter > all_height_Y_last_cut_first/2)
            {
                m_Control.need_TurnLeft = 1;
            }
            if(right_counter > all_height_Y_last_cut_first/2)
            {
                m_Control.need_TurnRight = 1;
            }
            
        }
    }
    */
    
    do//确定一些事情=>确定本场大致信息
    {
        for(uint8 loop = m_ImageAbstract.Last_Y_Position;loop > m_ImageAbstract.Start_Y_Position;loop--)
        {
            if((255 != m_ImageAbstract.Left[loop])||(255 != m_ImageAbstract.Right[loop]))
            {
                m_ImageAbstract.Last_Y_Position = loop;//
                break;//确定本次
            }
        }
      
        sint16 all_height_Y_last_cut_first = m_ImageAbstract.Last_Y_Position - m_ImageAbstract.Start_Y_Position;
        
        uint32 central_counter = 0;
        uint8 last = (all_height_Y_last_cut_first > 30)?30:all_height_Y_last_cut_first;
        uint8 time_counter = 0;
        
        for(uint8 loop = m_ImageAbstract.Start_Y_Position;//整体循环
                  loop < last + m_ImageAbstract.Start_Y_Position;
                  loop ++)
        {
            central_counter += m_ImageAbstract.Central[loop];
            time_counter ++;
        }
        if(0 != time_counter)
        {//以下为
            m_ImageAbstract.LastFrame_CentralPos = central_counter / time_counter;
            m_ImageAbstract.LastFrame_LeftPos = (m_ImageAbstract.LastFrame_CentralPos 
                                               - m_ImageAbstract.width[m_ImageAbstract.Start_Y_Position]/2 > 0)?
                                                (m_ImageAbstract.LastFrame_CentralPos 
                                               - m_ImageAbstract.width[m_ImageAbstract.Start_Y_Position]/2):
                                                 0;
            m_ImageAbstract.LastFrame_RightPos = (m_ImageAbstract.LastFrame_CentralPos 
                                                + m_ImageAbstract.width[m_ImageAbstract.Start_Y_Position]/2 < constNum_X_MaxCounter)?
                                                 (m_ImageAbstract.LastFrame_CentralPos 
                                                + m_ImageAbstract.width[m_ImageAbstract.Start_Y_Position]/2):
                                                  constNum_X_MaxCounter;
        }
    }while(0);

    
    
    
    
}


uint16 n_getSteerMiddleLine()//舵机控制策略
{
    sint16 all_height_Y_last_cut_first = m_ImageAbstract.Last_Y_Position - m_ImageAbstract.Start_Y_Position;
    uint16 central_counter = 0;
   
    //if(all_height_Y_last_cut_first < 30)//小于此时将进入判定
    //{
        uint8 last = (all_height_Y_last_cut_first > 30)?30:all_height_Y_last_cut_first;
        uint8 time_counter = 0;
        for(uint8 loop = m_ImageAbstract.Start_Y_Position;//整体循环
                  loop < last + m_ImageAbstract.Start_Y_Position;
                  loop ++)
        {
            central_counter += m_ImageAbstract.Central[loop];
            time_counter ++;
        }
        if(0 != time_counter)
        {
            central_counter = central_counter / time_counter;
        }
    //}
    
    return central_counter;
}