###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      27/Sep/2014  14:54:43 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\创作室\飞思卡尔智能小车\调试板\遥控器\ShunAn_Panel\Bl #
#                    uetooth.c                                                #
#    Command line =  D:\创作室\飞思卡尔智能小车\调试板\遥控器\ShunAn_Panel\Bl #
#                    uetooth.c -D IAR -D TWR_K60F120M -lCN                    #
#                    D:\创作室\飞思卡尔智能小车\调试板\遥控器\RAM_128KB\List\ #
#                     -lB D:\创作室\飞思卡尔智能小车\调试板\遥控器\RAM_128KB\ #
#                    List\ -o D:\创作室\飞思卡尔智能小车\调试板\遥控器\RAM_12 #
#                    8KB\Obj\ --no_cse --no_unroll --no_inline                #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\创作室\飞思卡尔智能小车\调试板\遥控器\ -I   #
#                    D:\创作室\飞思卡尔智能小车\调试板\遥控器\Library\ -I     #
#                    D:\创作室\飞思卡尔智能小车\调试板\遥控器\Library\Blessed #
#                    Alien\ -I D:\创作室\飞思卡尔智能小车\调试板\遥控器\ShunA #
#                    n_Panel\ -Ol --use_c++_inline                            #
#    List file    =  D:\创作室\飞思卡尔智能小车\调试板\遥控器\RAM_128KB\List\ #
#                    Bluetooth.lst                                            #
#    Object file  =  D:\创作室\飞思卡尔智能小车\调试板\遥控器\RAM_128KB\Obj\B #
#                    luetooth.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\创作室\飞思卡尔智能小车\调试板\遥控器\ShunAn_Panel\Bluetooth.c
      1          /**
      2          /. -----------------------//k60底层库//-------------------------
      3          
      4          /. 测试硬件平台：K60
      5           . 版权所有：朱葛峻 
      6           . 制作者：朱葛峻
      7           . 文件名：alienUART.c
      8           . 用途：
      9           . 最后修改日期: 20140117
     10          */
     11          #include "MK60F15.h"
     12          #include "ShunAn_Lib.h"
     13          #include "start_ShunAn.h"
     14          #include "BlessedAlien.h"
     15          
     16          #include "Bluetooth.h"
     17          /******************************************************************************/
     18          /******************************************************************************/
     19          /******************************************************************************/
     20          /******************************************************************************/
     21          /******************************************************************************/

   \                                 In section .bss, align 4
     22          BlueTooth_Buffer g_RecBuffer;
   \                     g_RecBuffer:
   \   00000000                      DS8 2028

   \                                 In section .bss, align 4
     23          void*(*v_BlueTooth2Data)(BlueTooth_Buffer *);
   \                     v_BlueTooth2Data:
   \   00000000                      DS8 4
     24          /******************************************************************************/
     25          /******************************************************************************/
     26          /******************************************************************************/
     27          /******************************************************************************/
     28          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     29          void __v_Uart_Init_(uint32 BaudRate)
     30          {   
   \                     __v_Uart_Init_: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
     31              // 常参量
     32              uint32 tempReg  = 0;
   \   00000002   0x2100             MOVS     R1,#+0
     33              uint32 BdRtBits = 0;
   \   00000004   0x2200             MOVS     R2,#+0
     34              uint32 BRFAdjst = 0;
   \   00000006   0x2300             MOVS     R3,#+0
     35              // 设置时钟
     36              SIM_SCGC4 |= SIM_SCGC4_UART3_MASK;
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable5  ;; 0x40048034
   \   0000000C   0x6824             LDR      R4,[R4, #+0]
   \   0000000E   0xF454 0x5400      ORRS     R4,R4,#0x2000
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable5  ;; 0x40048034
   \   00000016   0x602C             STR      R4,[R5, #+0]
     37              SIM_SCGC5 |= SIM_SCGC5_PORTC_MASK|SIM_SCGC5_PORTE_MASK|SIM_SCGC5_PORTB_MASK ;//使能PORTE时钟
   \   00000018   0x....             LDR.N    R4,??DataTable5_1  ;; 0x40048038
   \   0000001A   0x6824             LDR      R4,[R4, #+0]
   \   0000001C   0xF454 0x5430      ORRS     R4,R4,#0x2C00
   \   00000020   0x....             LDR.N    R5,??DataTable5_1  ;; 0x40048038
   \   00000022   0x602C             STR      R4,[R5, #+0]
     38              // 设置引脚参数
     39              PORTC_PCR16 |= 0x00000300u;//引脚复用选择UART3_RX
   \   00000024   0x....             LDR.N    R4,??DataTable5_2  ;; 0x4004b040
   \   00000026   0x6824             LDR      R4,[R4, #+0]
   \   00000028   0xF454 0x7440      ORRS     R4,R4,#0x300
   \   0000002C   0x....             LDR.N    R5,??DataTable5_2  ;; 0x4004b040
   \   0000002E   0x602C             STR      R4,[R5, #+0]
     40              PORTC_PCR17 |= 0x00000300u;//引脚复用选择UART3_RX
   \   00000030   0x....             LDR.N    R4,??DataTable5_3  ;; 0x4004b044
   \   00000032   0x6824             LDR      R4,[R4, #+0]
   \   00000034   0xF454 0x7440      ORRS     R4,R4,#0x300
   \   00000038   0x....             LDR.N    R5,??DataTable5_3  ;; 0x4004b044
   \   0000003A   0x602C             STR      R4,[R5, #+0]
     41              PORTE_PCR4 |= 0x00000000u;//引脚复用选择UART3_RX
   \   0000003C   0x....             LDR.N    R4,??DataTable5_4  ;; 0x4004d010
   \   0000003E   0x....             LDR.N    R5,??DataTable5_4  ;; 0x4004d010
   \   00000040   0x682D             LDR      R5,[R5, #+0]
   \   00000042   0x6025             STR      R5,[R4, #+0]
     42              PORTE_PCR5 |= 0x00000000u;//引脚复用选择UART3_RX
   \   00000044   0x....             LDR.N    R4,??DataTable5_5  ;; 0x4004d014
   \   00000046   0x....             LDR.N    R5,??DataTable5_5  ;; 0x4004d014
   \   00000048   0x682D             LDR      R5,[R5, #+0]
   \   0000004A   0x6025             STR      R5,[R4, #+0]
     43              PORTB_PCR10 |= 0x00000000u;//引脚复用选择UART3_RX
   \   0000004C   0x....             LDR.N    R4,??DataTable5_6  ;; 0x4004a028
   \   0000004E   0x....             LDR.N    R5,??DataTable5_6  ;; 0x4004a028
   \   00000050   0x682D             LDR      R5,[R5, #+0]
   \   00000052   0x6025             STR      R5,[R4, #+0]
     44              PORTB_PCR11 |= 0x00000000u;//引脚复用选择UART3_RX
   \   00000054   0x....             LDR.N    R4,??DataTable5_7  ;; 0x4004a02c
   \   00000056   0x....             LDR.N    R5,??DataTable5_7  ;; 0x4004a02c
   \   00000058   0x682D             LDR      R5,[R5, #+0]
   \   0000005A   0x6025             STR      R5,[R4, #+0]
     45              // 关闭接收及发送器，等待触发时波特率生成
     46              (UART3_BASE_PTR)->C2 &= ~( UART_C2_TE_MASK | UART_C2_RE_MASK );
   \   0000005C   0x....             LDR.N    R4,??DataTable5_8  ;; 0x4006d003
   \   0000005E   0x7824             LDRB     R4,[R4, #+0]
   \   00000060   0xF014 0x04F3      ANDS     R4,R4,#0xF3
   \   00000064   0x....             LDR.N    R5,??DataTable5_8  ;; 0x4006d003
   \   00000066   0x702C             STRB     R4,[R5, #+0]
     47              // C1设置默认
     48              (UART3_BASE_PTR)->C1  = 0;
   \   00000068   0x....             LDR.N    R4,??DataTable5_9  ;; 0x4006d002
   \   0000006A   0x2500             MOVS     R5,#+0
   \   0000006C   0x7025             STRB     R5,[R4, #+0]
     49              // 设置波特率
     50              BdRtBits = (uint16)((bus_clk_khz * 1000)/(BaudRate << 4));
   \   0000006E   0x....             LDR.N    R4,??DataTable5_10
   \   00000070   0x6824             LDR      R4,[R4, #+0]
   \   00000072   0xF44F 0x757A      MOV      R5,#+1000
   \   00000076   0x436C             MULS     R4,R5,R4
   \   00000078   0x0105             LSLS     R5,R0,#+4
   \   0000007A   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   0000007E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000080   0x0022             MOVS     R2,R4
     51              tempReg = UART_BDH_REG(UART3_BASE_PTR) & ~(UART_BDH_SBR(0x1F));
   \   00000082   0x....             LDR.N    R4,??DataTable5_11  ;; 0x4006d000
   \   00000084   0x7824             LDRB     R4,[R4, #+0]
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x0964             LSRS     R4,R4,#+5
   \   0000008A   0x0164             LSLS     R4,R4,#+5
   \   0000008C   0x0021             MOVS     R1,R4
     52              (UART3_BASE_PTR)->BDH = tempReg |  UART_BDH_SBR(((BdRtBits & 0x1F00) >> 8));
   \   0000008E   0x0A14             LSRS     R4,R2,#+8
   \   00000090   0xF014 0x041F      ANDS     R4,R4,#0x1F
   \   00000094   0x4321             ORRS     R1,R4,R1
   \   00000096   0x....             LDR.N    R4,??DataTable5_11  ;; 0x4006d000
   \   00000098   0x7021             STRB     R1,[R4, #+0]
     53              (UART3_BASE_PTR)->BDL = (uint8)(BdRtBits & UART_BDL_SBR_MASK);
   \   0000009A   0x....             LDR.N    R1,??DataTable5_12  ;; 0x4006d001
   \   0000009C   0x700A             STRB     R2,[R1, #+0]
     54              BRFAdjst = ((((bus_clk_khz*1000)<<5)/(BaudRate <<4)) - (BdRtBits <<5));
   \   0000009E   0x....             LDR.N    R1,??DataTable5_10
   \   000000A0   0x6809             LDR      R1,[R1, #+0]
   \   000000A2   0xF44F 0x747A      MOV      R4,#+1000
   \   000000A6   0x4361             MULS     R1,R4,R1
   \   000000A8   0x0149             LSLS     R1,R1,#+5
   \   000000AA   0x0100             LSLS     R0,R0,#+4
   \   000000AC   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   000000B0   0xEBB0 0x1042      SUBS     R0,R0,R2, LSL #+5
   \   000000B4   0x0003             MOVS     R3,R0
     55              tempReg = UART_C4_REG(UART3_BASE_PTR) & ~(UART_C4_BRFA(0x1F));
   \   000000B6   0x....             LDR.N    R0,??DataTable5_13  ;; 0x4006d00a
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x0941             LSRS     R1,R0,#+5
   \   000000BE   0x0149             LSLS     R1,R1,#+5
     56              (UART3_BASE_PTR)->C4 = tempReg |  UART_C4_BRFA(BRFAdjst);
   \   000000C0   0xF013 0x001F      ANDS     R0,R3,#0x1F
   \   000000C4   0x4308             ORRS     R0,R0,R1
   \   000000C6   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4006d00a
   \   000000C8   0x7008             STRB     R0,[R1, #+0]
     57              // 设置接收FIFO
     58             // (UART3_BASE_PTR)->RWFIFO = 0;
     59            //  (UART3_BASE_PTR)->PFIFO = UART_PFIFO_RXFE_MASK | UART_PFIFO_RXFIFOSIZE(4); //
     60            //  (UART3_BASE_PTR)->RWFIFO = 1;
     61            //  (UART3_BASE_PTR)->CFIFO = UART_CFIFO_RXUFE_MASK; //
     62              // 触发接收器及发送器使能，触发生成波特率
     63              UART_C2_REG(UART3_BASE_PTR) |= (UART_C2_TE_MASK | UART_C2_RE_MASK );
   \   000000CA   0x....             LDR.N    R0,??DataTable5_8  ;; 0x4006d003
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0xF050 0x000C      ORRS     R0,R0,#0xC
   \   000000D2   0x....             LDR.N    R1,??DataTable5_8  ;; 0x4006d003
   \   000000D4   0x7008             STRB     R0,[R1, #+0]
     64              //
     65              (UART3_BASE_PTR)->C5 = 0x00u;
   \   000000D6   0x....             LDR.N    R0,??DataTable5_14  ;; 0x4006d00b
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x7001             STRB     R1,[R0, #+0]
     66              return;
   \   000000DC   0xBC30             POP      {R4,R5}
   \   000000DE   0x4770             BX       LR               ;; return
     67          }
     68          /*************************************************************************
     69          //
     70          *************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     71          void __v_Uart_TxOne_(unsigned char sendInfor)
     72          {
     73              // 等待发送缓冲区空 Transmit Data Register Empty Flag == 1 时退出循环
     74              while(!( (UART3_BASE_PTR->S1) & UART_S1_TDRE_MASK));
   \                     __v_Uart_TxOne_: (+1)
   \                     ??__v_Uart_TxOne__0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_15  ;; 0x4006d004
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x0609             LSLS     R1,R1,#+24
   \   00000006   0xD5FB             BPL.N    ??__v_Uart_TxOne__0
     75              
     76              // 当TDRE为1时，执行发送数据指令。
     77              // 发送数据
     78              (UART3_BASE_PTR)->D = (uint8)sendInfor;
   \   00000008   0x....             LDR.N    R1,??DataTable5_16  ;; 0x4006d007
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
     79          }
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     80          void __v_Uart_TxInt16_(unsigned short int sendUint)
     81          {
   \                     __v_Uart_TxInt16_: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     82              // 先搞后低
     83              __v_Uart_TxOne_((uint8)((sendUint>>8)&(0x00FFu)));
   \   00000004   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000006   0x0A20             LSRS     R0,R4,#+8
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       __v_Uart_TxOne_
     84              // vDelayMuchMs(100);
     85              __v_Uart_TxOne_((uint8)((sendUint)&(0x00FFu)));
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       __v_Uart_TxOne_
     86          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
     87          

   \                                 In section .text, align 2, keep-with-next
     88          void __v_Uart_TxInt32_(unsigned long int sendUint)
     89          {
   \                     __v_Uart_TxInt32_: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     90              __v_Uart_TxInt16_((uint16)((sendUint>>16)&(0x0000FFFFu)));
   \   00000004   0x0C20             LSRS     R0,R4,#+16
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x.... 0x....      BL       __v_Uart_TxInt16_
     91              //vDelayMuchMs(100);
     92              __v_Uart_TxInt16_((uint16)((sendUint)&(0x0000FFFFu)));
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x.... 0x....      BL       __v_Uart_TxInt16_
     93          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
     94          
     95          /*
     96           * 三种接收格式
     97           */

   \                                 In section .text, align 2, keep-with-next
     98          void __v_uart_getchar (char *ch)
     99          {
    100              while (!(UART_S1_REG(UART3_BASE_PTR) & UART_S1_RDRF_MASK));       //等待接收满了
   \                     __v_uart_getchar: (+1)
   \                     ??__v_uart_getchar_0: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_15  ;; 0x4006d004
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26
   \   00000006   0xD5FB             BPL.N    ??__v_uart_getchar_0
    101              *ch =  UART_D_REG(UART3_BASE_PTR);
   \   00000008   0x....             LDR.N    R1,??DataTable5_16  ;; 0x4006d007
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
    102          }
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    103          uint8 __v_uart_getOnce (char *ch)
    104          {
    105              uint32 timer_Delay = 1000000; // 硬件延迟
   \                     __v_uart_getOnce: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable5_17  ;; 0xf4240
    106              while(timer_Delay--)
   \                     ??__v_uart_getOnce_0: (+1)
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0x1E51             SUBS     R1,R2,#+1
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD008             BEQ.N    ??__v_uart_getOnce_1
    107              {
    108                  if (UART_S1_REG(UART3_BASE_PTR) & UART_S1_RDRF_MASK)
   \   0000000A   0x....             LDR.N    R2,??DataTable5_15  ;; 0x4006d004
   \   0000000C   0x7812             LDRB     R2,[R2, #+0]
   \   0000000E   0x0692             LSLS     R2,R2,#+26
   \   00000010   0xD5F7             BPL.N    ??__v_uart_getOnce_0
    109                  {
    110                      *ch =  UART_D_REG(UART3_BASE_PTR);return 0;
   \   00000012   0x....             LDR.N    R1,??DataTable5_16  ;; 0x4006d007
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE000             B.N      ??__v_uart_getOnce_2
    111                  }
    112              }
    113              return 1;
   \                     ??__v_uart_getOnce_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \                     ??__v_uart_getOnce_2: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
    114          }

   \                                 In section .text, align 2, keep-with-next
    115          uint8 u8_uart_getAll ( BlueTooth_Buffer * _RecBuffer )
    116          {
   \                     u8_uart_getAll: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    117              char ch = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
    118              uint8 isGetData = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE006             B.N      ??u8_uart_getAll_0
    119              while( !__v_uart_getOnce(&ch) )
    120              {
    121                  _RecBuffer->Buffer[g_RecBuffer.BufferSize] = ch;
    122                  if( 0xFF == ch ){_RecBuffer->MaySign_Buffer[_RecBuffer->MaySign_BufferSize] = g_RecBuffer.BufferSize;_RecBuffer->MaySign_BufferSize++;} // 记录关键信息
    123                  if( _RecBuffer->BufferSize < DE_MAX_bufferSize ){_RecBuffer->BufferSize++;}
    124                  else{_RecBuffer->flags_single.flags_OverRun = 1;return 1;} // 限幅
    125                  if(_RecBuffer->BufferSize > (DE_MAX_bufferSize>>1)){_RecBuffer->flags_single.flags_Half = 1;}
    126                                                                 else{_RecBuffer->flags_single.flags_Half = 0;} // 半九十记录
   \                     ??u8_uart_getAll_1: (+1)
   \   0000000E   0xF894 0x07E9      LDRB     R0,[R4, #+2025]
   \   00000012   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000016   0xF884 0x07E9      STRB     R0,[R4, #+2025]
    127                  isGetData = 1;
   \                     ??u8_uart_getAll_2: (+1)
   \   0000001A   0x2501             MOVS     R5,#+1
   \                     ??u8_uart_getAll_0: (+1)
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x.... 0x....      BL       __v_uart_getOnce
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD12F             BNE.N    ??u8_uart_getAll_3
   \   00000026   0x....             LDR.N    R0,??DataTable5_18
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x1900             ADDS     R0,R0,R4
   \   0000002C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000030   0x7101             STRB     R1,[R0, #+4]
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0x28FF             CMP      R0,#+255
   \   00000038   0xD10B             BNE.N    ??u8_uart_getAll_4
   \   0000003A   0xF894 0x07D4      LDRB     R0,[R4, #+2004]
   \   0000003E   0x1900             ADDS     R0,R0,R4
   \   00000040   0x....             LDR.N    R1,??DataTable5_18
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0xF880 0x17D5      STRB     R1,[R0, #+2005]
   \   00000048   0xF894 0x07D4      LDRB     R0,[R4, #+2004]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0xF884 0x07D4      STRB     R0,[R4, #+2004]
   \                     ??u8_uart_getAll_4: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000058   0xD20D             BCS.N    ??u8_uart_getAll_5
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
   \   0000005E   0x6020             STR      R0,[R4, #+0]
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000066   0xD9D2             BLS.N    ??u8_uart_getAll_1
   \   00000068   0xF894 0x07E9      LDRB     R0,[R4, #+2025]
   \   0000006C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000070   0xF884 0x07E9      STRB     R0,[R4, #+2025]
   \   00000074   0xE7D1             B.N      ??u8_uart_getAll_2
   \                     ??u8_uart_getAll_5: (+1)
   \   00000076   0xF894 0x07E9      LDRB     R0,[R4, #+2025]
   \   0000007A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000007E   0xF884 0x07E9      STRB     R0,[R4, #+2025]
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xE015             B.N      ??u8_uart_getAll_6
    128              }
    129              if( 0 == _RecBuffer->BufferSize ){_RecBuffer->flags_single.flags_Full = 1;}
   \                     ??u8_uart_getAll_3: (+1)
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD106             BNE.N    ??u8_uart_getAll_7
   \   0000008C   0xF894 0x07E9      LDRB     R0,[R4, #+2025]
   \   00000090   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000094   0xF884 0x07E9      STRB     R0,[R4, #+2025]
   \   00000098   0xE005             B.N      ??u8_uart_getAll_8
    130                                               else{_RecBuffer->flags_single.flags_Full = 0;} // 空记录
   \                     ??u8_uart_getAll_7: (+1)
   \   0000009A   0xF894 0x07E9      LDRB     R0,[R4, #+2025]
   \   0000009E   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   000000A2   0xF884 0x07E9      STRB     R0,[R4, #+2025]
    131              if(1 == isGetData){return 0;}
   \                     ??u8_uart_getAll_8: (+1)
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D01             CMP      R5,#+1
   \   000000AA   0xD101             BNE.N    ??u8_uart_getAll_9
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE000             B.N      ??u8_uart_getAll_6
    132                            else{return 1;}
   \                     ??u8_uart_getAll_9: (+1)
   \   000000B0   0x2001             MOVS     R0,#+1
   \                     ??u8_uart_getAll_6: (+1)
   \   000000B2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    133          }
    134          
    135          /******************************************************************************/

   \                                 In section .bss, align 4
    136          s_Data_GyroAccel Data_UART_rec;
   \                     Data_UART_rec:
   \   00000000                      DS8 2404
    137          /******************************************************************************/
    138          /* 
    139           * 起始位定义：1*16 2
    140           * 接收协议一：陀螺仪加速度计 / 6*16 = 12*8 = 12Bytes => 16Bytes 
    141           */

   \                                 In section .text, align 2, keep-with-next
    142          void v_Tooth_GyroAccel (BlueTooth_Buffer * Rec) // 16Bytes 
    143          {
   \                     v_Tooth_GyroAccel: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    144              /*
    145               * 发送协议：0xFFEA + x陀螺仪(2) + y陀螺仪(2) + z陀螺仪(2) + x加速度(2) + y加速度(2) + z加速度(2)
    146               */
    147              uint32 max_RecNum = Rec->BufferSize; // 最大数值
   \   00000002   0x6801             LDR      R1,[R0, #+0]
    148              uint32 max_FF_RecNum = Rec->MaySign_BufferSize; // FF存在数量
   \   00000004   0xF890 0x27D4      LDRB     R2,[R0, #+2004]
    149              // 搜寻：
    150              for(uint8 loop = 0;loop < max_FF_RecNum;loop++)
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0xE0AD             B.N      ??v_Tooth_GyroAccel_0
    151              {
    152                  if(Rec->MaySign_Buffer[loop] < (max_RecNum - 1)) // 0xFF仅为可能，下一位才是重点
   \                     ??v_Tooth_GyroAccel_1: (+1)
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0x181C             ADDS     R4,R3,R0
   \   00000010   0xF894 0x47D5      LDRB     R4,[R4, #+2005]
   \   00000014   0x1E4D             SUBS     R5,R1,#+1
   \   00000016   0x42AC             CMP      R4,R5
   \   00000018   0xF080 0x80A5      BCS.W    ??v_Tooth_GyroAccel_2
    153                  { // 情况为真
    154                      if(0xEA == Rec->Buffer[(Rec->MaySign_Buffer[loop]+1)]) // 确认是否可能
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x181C             ADDS     R4,R3,R0
   \   00000020   0xF894 0x47D5      LDRB     R4,[R4, #+2005]
   \   00000024   0x1824             ADDS     R4,R4,R0
   \   00000026   0x7964             LDRB     R4,[R4, #+5]
   \   00000028   0x2CEA             CMP      R4,#+234
   \   0000002A   0xF040 0x809C      BNE.W    ??v_Tooth_GyroAccel_2
    155                      {
    156                          uint8 vaild_bit = 0;
   \   0000002E   0x2400             MOVS     R4,#+0
    157                          uint32 next = Rec->MaySign_Buffer[loop] + 16;
   \   00000030   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000032   0x181D             ADDS     R5,R3,R0
   \   00000034   0xF895 0x57D5      LDRB     R5,[R5, #+2005]
   \   00000038   0x3510             ADDS     R5,R5,#+16
    158                          if( next < (max_RecNum - 1)) //进行检测
   \   0000003A   0x1E4E             SUBS     R6,R1,#+1
   \   0000003C   0x42B5             CMP      R5,R6
   \   0000003E   0xD209             BCS.N    ??v_Tooth_GyroAccel_3
    159                          {
    160                              vaild_bit = 1;
   \   00000040   0x2401             MOVS     R4,#+1
    161                              if(( 0xFF == Rec->Buffer[next] ) && ( 0xEA == Rec->Buffer[next+1] ))
   \   00000042   0x182E             ADDS     R6,R5,R0
   \   00000044   0x7936             LDRB     R6,[R6, #+4]
   \   00000046   0x2EFF             CMP      R6,#+255
   \   00000048   0xD104             BNE.N    ??v_Tooth_GyroAccel_3
   \   0000004A   0x182D             ADDS     R5,R5,R0
   \   0000004C   0x796D             LDRB     R5,[R5, #+5]
   \   0000004E   0x2DEA             CMP      R5,#+234
   \   00000050   0xD100             BNE.N    ??v_Tooth_GyroAccel_3
    162                              {
    163                                  vaild_bit = 0;
   \   00000052   0x2400             MOVS     R4,#+0
    164                              }
    165                          }
    166                          if(0 == vaild_bit)
   \                     ??v_Tooth_GyroAccel_3: (+1)
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xF040 0x8085      BNE.W    ??v_Tooth_GyroAccel_2
    167                          {
    168                              // 得出最终数据
    169                              register uint16 num = Data_UART_rec.Rec_num;
   \   0000005C   0x....             LDR.N    R4,??DataTable5_19
   \   0000005E   0xF8B4 0x4960      LDRH     R4,[R4, #+2400]
    170                              Data_UART_rec.Gyro_x[num] = ((Rec->Buffer[ Rec->MaySign_Buffer[loop] +  2 ])<<8)
    171                                                          |((Rec->Buffer[ Rec->MaySign_Buffer[loop] + 3 ]));
   \   00000062   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000064   0x181D             ADDS     R5,R3,R0
   \   00000066   0xF895 0x57D5      LDRB     R5,[R5, #+2005]
   \   0000006A   0x182D             ADDS     R5,R5,R0
   \   0000006C   0x79AD             LDRB     R5,[R5, #+6]
   \   0000006E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000070   0x181E             ADDS     R6,R3,R0
   \   00000072   0xF896 0x67D5      LDRB     R6,[R6, #+2005]
   \   00000076   0x1836             ADDS     R6,R6,R0
   \   00000078   0x79F6             LDRB     R6,[R6, #+7]
   \   0000007A   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   \   0000007E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000080   0x....             LDR.N    R6,??DataTable5_19
   \   00000082   0xF826 0x5014      STRH     R5,[R6, R4, LSL #+1]
    172                              Data_UART_rec.Gyro_y[num] = ((Rec->Buffer[ Rec->MaySign_Buffer[loop] +  4 ])<<8)
    173                                                          |((Rec->Buffer[ Rec->MaySign_Buffer[loop] + 5 ]));
   \   00000086   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000088   0x181D             ADDS     R5,R3,R0
   \   0000008A   0xF895 0x57D5      LDRB     R5,[R5, #+2005]
   \   0000008E   0x182D             ADDS     R5,R5,R0
   \   00000090   0x7A2D             LDRB     R5,[R5, #+8]
   \   00000092   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000094   0x181E             ADDS     R6,R3,R0
   \   00000096   0xF896 0x67D5      LDRB     R6,[R6, #+2005]
   \   0000009A   0x1836             ADDS     R6,R6,R0
   \   0000009C   0x7A76             LDRB     R6,[R6, #+9]
   \   0000009E   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   \   000000A2   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000A4   0x....             LDR.N    R6,??DataTable5_19
   \   000000A6   0xEB16 0x0644      ADDS     R6,R6,R4, LSL #+1
   \   000000AA   0xF8A6 0x5190      STRH     R5,[R6, #+400]
    174                              Data_UART_rec.Gyro_z[num] = ((Rec->Buffer[ Rec->MaySign_Buffer[loop] +  6 ])<<8)
    175                                                          |((Rec->Buffer[ Rec->MaySign_Buffer[loop] + 7 ]));
   \   000000AE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000B0   0x181D             ADDS     R5,R3,R0
   \   000000B2   0xF895 0x57D5      LDRB     R5,[R5, #+2005]
   \   000000B6   0x182D             ADDS     R5,R5,R0
   \   000000B8   0x7AAD             LDRB     R5,[R5, #+10]
   \   000000BA   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000BC   0x181E             ADDS     R6,R3,R0
   \   000000BE   0xF896 0x67D5      LDRB     R6,[R6, #+2005]
   \   000000C2   0x1836             ADDS     R6,R6,R0
   \   000000C4   0x7AF6             LDRB     R6,[R6, #+11]
   \   000000C6   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   \   000000CA   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000CC   0x....             LDR.N    R6,??DataTable5_19
   \   000000CE   0xEB16 0x0644      ADDS     R6,R6,R4, LSL #+1
   \   000000D2   0xF8A6 0x5320      STRH     R5,[R6, #+800]
    176                              Data_UART_rec.Accel_x[num] =((Rec->Buffer[ Rec->MaySign_Buffer[loop] +  8 ])<<8)
    177                                                          |((Rec->Buffer[ Rec->MaySign_Buffer[loop] + 9 ]));
   \   000000D6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D8   0x181D             ADDS     R5,R3,R0
   \   000000DA   0xF895 0x57D5      LDRB     R5,[R5, #+2005]
   \   000000DE   0x182D             ADDS     R5,R5,R0
   \   000000E0   0x7B2D             LDRB     R5,[R5, #+12]
   \   000000E2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000E4   0x181E             ADDS     R6,R3,R0
   \   000000E6   0xF896 0x67D5      LDRB     R6,[R6, #+2005]
   \   000000EA   0x1836             ADDS     R6,R6,R0
   \   000000EC   0x7B76             LDRB     R6,[R6, #+13]
   \   000000EE   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   \   000000F2   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000F4   0x....             LDR.N    R6,??DataTable5_19
   \   000000F6   0xEB16 0x0644      ADDS     R6,R6,R4, LSL #+1
   \   000000FA   0xF8A6 0x54B0      STRH     R5,[R6, #+1200]
    178                              Data_UART_rec.Accel_y[num] =((Rec->Buffer[ Rec->MaySign_Buffer[loop] +  10 ])<<8)
    179                                                          |((Rec->Buffer[ Rec->MaySign_Buffer[loop] + 11 ]));
   \   000000FE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000100   0x181D             ADDS     R5,R3,R0
   \   00000102   0xF895 0x57D5      LDRB     R5,[R5, #+2005]
   \   00000106   0x182D             ADDS     R5,R5,R0
   \   00000108   0x7BAD             LDRB     R5,[R5, #+14]
   \   0000010A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000010C   0x181E             ADDS     R6,R3,R0
   \   0000010E   0xF896 0x67D5      LDRB     R6,[R6, #+2005]
   \   00000112   0x1836             ADDS     R6,R6,R0
   \   00000114   0x7BF6             LDRB     R6,[R6, #+15]
   \   00000116   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   \   0000011A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000011C   0x....             LDR.N    R6,??DataTable5_19
   \   0000011E   0xEB16 0x0644      ADDS     R6,R6,R4, LSL #+1
   \   00000122   0xF8A6 0x5640      STRH     R5,[R6, #+1600]
    180                              Data_UART_rec.Accel_z[num] =((Rec->Buffer[ Rec->MaySign_Buffer[loop] +  12 ])<<8)
    181                                                          |((Rec->Buffer[ Rec->MaySign_Buffer[loop] + 13 ]));
   \   00000126   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000128   0x181D             ADDS     R5,R3,R0
   \   0000012A   0xF895 0x57D5      LDRB     R5,[R5, #+2005]
   \   0000012E   0x182D             ADDS     R5,R5,R0
   \   00000130   0x7C2D             LDRB     R5,[R5, #+16]
   \   00000132   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000134   0x181E             ADDS     R6,R3,R0
   \   00000136   0xF896 0x67D5      LDRB     R6,[R6, #+2005]
   \   0000013A   0x1836             ADDS     R6,R6,R0
   \   0000013C   0x7C76             LDRB     R6,[R6, #+17]
   \   0000013E   0xEA56 0x2505      ORRS     R5,R6,R5, LSL #+8
   \   00000142   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000144   0x....             LDR.N    R6,??DataTable5_19
   \   00000146   0xEB16 0x0444      ADDS     R4,R6,R4, LSL #+1
   \   0000014A   0xF8A4 0x57D0      STRH     R5,[R4, #+2000]
    182                              Data_UART_rec.Rec_num ++;
   \   0000014E   0x....             LDR.N    R4,??DataTable5_19
   \   00000150   0xF8B4 0x4960      LDRH     R4,[R4, #+2400]
   \   00000154   0x1C64             ADDS     R4,R4,#+1
   \   00000156   0x....             LDR.N    R5,??DataTable5_19
   \   00000158   0xF8A5 0x4960      STRH     R4,[R5, #+2400]
    183                              // 清空原始数据
    184                              Rec->BufferSize = 0;
   \   0000015C   0x2400             MOVS     R4,#+0
   \   0000015E   0x6004             STR      R4,[R0, #+0]
    185                              Rec->MaySign_BufferSize = 0;
   \   00000160   0x2400             MOVS     R4,#+0
   \   00000162   0xF880 0x47D4      STRB     R4,[R0, #+2004]
    186                          }
    187                      }
    188                  }
    189              }
   \                     ??v_Tooth_GyroAccel_2: (+1)
   \   00000166   0x1C5B             ADDS     R3,R3,#+1
   \                     ??v_Tooth_GyroAccel_0: (+1)
   \   00000168   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000016A   0x4293             CMP      R3,R2
   \   0000016C   0xF4FF 0xAF4E      BCC.W    ??v_Tooth_GyroAccel_1
    190          }
   \   00000170   0xBC70             POP      {R4-R6}
   \   00000172   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x4004B040         DC32     0x4004b040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x4004B044         DC32     0x4004b044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x4004A028         DC32     0x4004a028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x4004A02C         DC32     0x4004a02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x4006D003         DC32     0x4006d003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x4006D002         DC32     0x4006d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     bus_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x4006D001         DC32     0x4006d001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x4006D00A         DC32     0x4006d00a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4006D00B         DC32     0x4006d00b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x4006D004         DC32     0x4006d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x4006D007         DC32     0x4006d007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x........         DC32     g_RecBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     Data_UART_rec

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   __v_Uart_Init_
       8   __v_Uart_TxInt16_
         8   -> __v_Uart_TxOne_
       8   __v_Uart_TxInt32_
         8   -> __v_Uart_TxInt16_
       0   __v_Uart_TxOne_
       0   __v_uart_getOnce
       0   __v_uart_getchar
      16   u8_uart_getAll
        16   -> __v_uart_getOnce
      12   v_Tooth_GyroAccel


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
    2404  Data_UART_rec
     224  __v_Uart_Init_
      24  __v_Uart_TxInt16_
      22  __v_Uart_TxInt32_
      14  __v_Uart_TxOne_
      32  __v_uart_getOnce
      16  __v_uart_getchar
    2028  g_RecBuffer
     180  u8_uart_getAll
       4  v_BlueTooth2Data
     372  v_Tooth_GyroAccel

 
 4 436 bytes in section .bss
   964 bytes in section .text
 
   964 bytes of CODE memory
 4 436 bytes of DATA memory

Errors: none
Warnings: none
