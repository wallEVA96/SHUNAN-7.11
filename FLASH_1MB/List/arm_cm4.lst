###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      29/Jun/2015  21:49:20 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\Library\arm_cm4.c                                #
#    Command line =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\Library\arm_cm4.c -D IAR -D TWR_K60F120M -lCN    #
#                    D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\FLASH_1MB\List\ -lB                              #
#                    D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\FLASH_1MB\List\ -o D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³ #
#                    °µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µÚÒ»´ú°å\FLASH_1MB\Obj\        #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=VFPv4_sp        #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈ #
#                    ýºÅ-ÆðÔ´-µÚÒ»´ú°å\ -I D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýº #
#                    Å\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µÚÒ»´ú°å\Library\ -I                #
#                    D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\Library\BlessedAlien\ -I                         #
#                    D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\ShunAn_Panel\ -Ol --use_c++_inline               #
#    List file    =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\FLASH_1MB\List\arm_cm4.lst                       #
#    Object file  =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µ #
#                    ÚÒ»´ú°å\FLASH_1MB\Obj\arm_cm4.o                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\Ë³°µÈýºÅ-ÆðÔ´-µÚÒ»´ú°å\Library\arm_cm4.c
      1          /*
      2           * ÎÄ¼þ:		arm_cm4.c
      3           * Ä¿µÄ:		ARM Cortex M4´¦ÀíÆ÷Í¨ÓÃµÄ¸ß¼¶ÊÂÎñ
      4           * ´´½¨Ê±¼ä£º            2014/5/18
      5           * ×÷Õß£º                ÖÐÄÏ´óÑ§¹­¼ý
      6           */
      7          
      8          #include "arm_cm4.h"
      9          #include "MK60F15.h"
     10          
     11          /***********************************************************************/
     12          /*
     13           * Configures the ARM system control register for STOP (deep sleep) mode
     14           * and then executes the WFI instruction to enter the mode.
     15           *
     16           * Parameters:
     17           * none
     18           *
     19           * Note: Might want to change this later to allow for passing in a parameter
     20           *       to optionally set the sleep on exit bit.
     21           */
     22          

   \                                 In section .text, align 4, keep-with-next
     23          void stop (void)
     24          {
     25          	/* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
     26          	SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
   \                     stop: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000008   0x....             LDR.N    R1,??DataTable4  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     27          
     28          	/* WFI instruction will start entry into STOP mode */
     29          	asm("WFI");
   \   0000000C   0xBF30             WFI
     30          }
   \   0000000E   0x4770             BX       LR               ;; return
     31          /***********************************************************************/
     32          /*
     33           * Configures the ARM system control register for WAIT (sleep) mode
     34           * and then executes the WFI instruction to enter the mode.
     35           *
     36           * Parameters:
     37           * none
     38           *
     39           * Note: Might want to change this later to allow for passing in a parameter
     40           *       to optionally set the sleep on exit bit.
     41           */
     42          

   \                                 In section .text, align 4, keep-with-next
     43          void wait (void)
     44          {
     45          	/* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
     46          	 * of deep sleep.
     47          	 */
     48          	SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;	
   \                     wait: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000008   0x....             LDR.N    R1,??DataTable4  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     49          
     50          	/* WFI instruction will start entry into WAIT mode */
     51          	asm("WFI");
   \   0000000C   0xBF30             WFI
     52          }
   \   0000000E   0x4770             BX       LR               ;; return
     53          /***********************************************************************/
     54          /*
     55           * Change the value of the vector table offset register to the specified value.
     56           *
     57           * Parameters:
     58           * vtor     new value to write to the VTOR
     59           */
     60          

   \                                 In section .text, align 2, keep-with-next
     61          void write_vtor (int vtor)
     62          {
     63                  /* Write the VTOR with the new value */
     64                  SCB_VTOR = vtor;	
   \                     write_vtor: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable4_1  ;; 0xe000ed08
   \   00000002   0x6008             STR      R0,[R1, #+0]
     65          }
   \   00000004   0x4770             BX       LR               ;; return
     66          /***********************************************************************/
     67          /*
     68           * Initialize the NVIC to enable the specified IRQ.
     69           * 
     70           * NOTE: The function only initializes the NVIC to enable a single IRQ. 
     71           * Interrupts will also need to be enabled in the ARM core. This can be 
     72           * done using the EnableInterrupts macro.
     73           *
     74           * Parameters:
     75           * irq    irq number to be enabled (the irq number NOT the vector number)
     76           */
     77          

   \                                 In section .text, align 2, keep-with-next
     78          void enable_irq (int irq)
     79          {
   \                     enable_irq: (+1)
   \   00000000   0xB410             PUSH     {R4}
     80              int div;
     81              
     82              /* Make sure that the IRQ is an allowable number. Right now up to 91 is 
     83               * used.
     84               */
     85              //if (irq > 91)
     86              //    printf("\nERR! Invalid IRQ value passed to enable irq function!\n");
     87              
     88              /* Determine which of the NVICISERs corresponds to the irq */
     89              div = irq/32;
   \   00000002   0x2120             MOVS     R1,#+32
   \   00000004   0xFB90 0xF1F1      SDIV     R1,R0,R1
     90              
     91              switch (div)
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD003             BEQ.N    ??enable_irq_0
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD035             BEQ.N    ??enable_irq_1
   \   00000010   0xD31A             BCC.N    ??enable_irq_2
   \   00000012   0xE04C             B.N      ??enable_irq_3
     92              {
     93              	case 0x0:
     94                        NVICICPR0 |= 1 << (irq%32);
   \                     ??enable_irq_0: (+1)
   \   00000014   0x....             LDR.N    R1,??DataTable4_2  ;; 0xe000e280
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2320             MOVS     R3,#+32
   \   0000001C   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000020   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000024   0x40A2             LSLS     R2,R2,R4
   \   00000026   0x4311             ORRS     R1,R2,R1
   \   00000028   0x....             LDR.N    R2,??DataTable4_2  ;; 0xe000e280
   \   0000002A   0x6011             STR      R1,[R2, #+0]
     95                        NVICISER0 |= 1 << (irq%32);
   \   0000002C   0x....             LDR.N    R1,??DataTable4_3  ;; 0xe000e100
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2320             MOVS     R3,#+32
   \   00000034   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000038   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   0000003C   0xFA12 0xF004      LSLS     R0,R2,R4
   \   00000040   0x4308             ORRS     R0,R0,R1
   \   00000042   0x....             LDR.N    R1,??DataTable4_3  ;; 0xe000e100
   \   00000044   0x6008             STR      R0,[R1, #+0]
     96                        break;
   \   00000046   0xE032             B.N      ??enable_irq_3
     97              	case 0x1:
     98                        NVICICPR1 |= 1 << (irq%32);
   \                     ??enable_irq_2: (+1)
   \   00000048   0x....             LDR.N    R1,??DataTable4_4  ;; 0xe000e284
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x2320             MOVS     R3,#+32
   \   00000050   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000054   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000058   0x40A2             LSLS     R2,R2,R4
   \   0000005A   0x4311             ORRS     R1,R2,R1
   \   0000005C   0x....             LDR.N    R2,??DataTable4_4  ;; 0xe000e284
   \   0000005E   0x6011             STR      R1,[R2, #+0]
     99                        NVICISER1 |= 1 << (irq%32);
   \   00000060   0x....             LDR.N    R1,??DataTable4_5  ;; 0xe000e104
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x2201             MOVS     R2,#+1
   \   00000066   0x2320             MOVS     R3,#+32
   \   00000068   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   0000006C   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   00000070   0xFA12 0xF004      LSLS     R0,R2,R4
   \   00000074   0x4308             ORRS     R0,R0,R1
   \   00000076   0x....             LDR.N    R1,??DataTable4_5  ;; 0xe000e104
   \   00000078   0x6008             STR      R0,[R1, #+0]
    100                        break;
   \   0000007A   0xE018             B.N      ??enable_irq_3
    101              	case 0x2:
    102                        NVICICPR2 |= 1 << (irq%32);
   \                     ??enable_irq_1: (+1)
   \   0000007C   0x....             LDR.N    R1,??DataTable4_6  ;; 0xe000e288
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0x2320             MOVS     R3,#+32
   \   00000084   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   00000088   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   0000008C   0x40A2             LSLS     R2,R2,R4
   \   0000008E   0x4311             ORRS     R1,R2,R1
   \   00000090   0x....             LDR.N    R2,??DataTable4_6  ;; 0xe000e288
   \   00000092   0x6011             STR      R1,[R2, #+0]
    103                        NVICISER2 |= 1 << (irq%32);
   \   00000094   0x....             LDR.N    R1,??DataTable4_7  ;; 0xe000e108
   \   00000096   0x6809             LDR      R1,[R1, #+0]
   \   00000098   0x2201             MOVS     R2,#+1
   \   0000009A   0x2320             MOVS     R3,#+32
   \   0000009C   0xFB90 0xF4F3      SDIV     R4,R0,R3
   \   000000A0   0xFB04 0x0413      MLS      R4,R4,R3,R0
   \   000000A4   0xFA12 0xF004      LSLS     R0,R2,R4
   \   000000A8   0x4308             ORRS     R0,R0,R1
   \   000000AA   0x....             LDR.N    R1,??DataTable4_7  ;; 0xe000e108
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    104                        break;
    105              }              
    106          }
   \                     ??enable_irq_3: (+1)
   \   000000AE   0xBC10             POP      {R4}
   \   000000B0   0x4770             BX       LR               ;; return
    107          /***********************************************************************/
    108          /*
    109           * Initialize the NVIC to disable the specified IRQ.
    110           * 
    111           * NOTE: The function only initializes the NVIC to disable a single IRQ. 
    112           * If you want to disable all interrupts, then use the DisableInterrupts
    113           * macro instead. 
    114           *
    115           * Parameters:
    116           * irq    irq number to be disabled (the irq number NOT the vector number)
    117           */
    118          

   \                                 In section .text, align 2, keep-with-next
    119          void disable_irq (int irq)
    120          {
    121              int div;
    122              
    123              /* Make sure that the IRQ is an allowable number. Right now up to 91 is 
    124               * used.
    125               */
    126              //if (irq > 91)
    127              //    printf("\nERR! Invalid IRQ value passed to disable irq function!\n");
    128              
    129              /* Determine which of the NVICICERs corresponds to the irq */
    130              div = irq/32;
   \                     disable_irq: (+1)
   \   00000000   0x2120             MOVS     R1,#+32
   \   00000002   0xFB90 0xF1F1      SDIV     R1,R0,R1
    131              
    132              switch (div)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD003             BEQ.N    ??disable_irq_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD017             BEQ.N    ??disable_irq_1
   \   0000000E   0xD30B             BCC.N    ??disable_irq_2
   \   00000010   0xE01F             B.N      ??disable_irq_3
    133              {
    134              	case 0x0:
    135                        NVICICER0 = 1 << (irq%32);
   \                     ??disable_irq_0: (+1)
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2220             MOVS     R2,#+32
   \   00000016   0xFB90 0xF3F2      SDIV     R3,R0,R2
   \   0000001A   0xFB03 0x0312      MLS      R3,R3,R2,R0
   \   0000001E   0xFA11 0xF003      LSLS     R0,R1,R3
   \   00000022   0x....             LDR.N    R1,??DataTable4_8  ;; 0xe000e180
   \   00000024   0x6008             STR      R0,[R1, #+0]
    136                        break;
   \   00000026   0xE014             B.N      ??disable_irq_3
    137              	case 0x1:
    138                        NVICICER1 = 1 << (irq%32);
   \                     ??disable_irq_2: (+1)
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x2220             MOVS     R2,#+32
   \   0000002C   0xFB90 0xF3F2      SDIV     R3,R0,R2
   \   00000030   0xFB03 0x0312      MLS      R3,R3,R2,R0
   \   00000034   0xFA11 0xF003      LSLS     R0,R1,R3
   \   00000038   0x....             LDR.N    R1,??DataTable4_9  ;; 0xe000e184
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    139                        break;
   \   0000003C   0xE009             B.N      ??disable_irq_3
    140              	case 0x2:
    141                        NVICICER2 = 1 << (irq%32);
   \                     ??disable_irq_1: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0x2220             MOVS     R2,#+32
   \   00000042   0xFB90 0xF3F2      SDIV     R3,R0,R2
   \   00000046   0xFB03 0x0312      MLS      R3,R3,R2,R0
   \   0000004A   0xFA11 0xF003      LSLS     R0,R1,R3
   \   0000004E   0x....             LDR.N    R1,??DataTable4_10  ;; 0xe000e188
   \   00000050   0x6008             STR      R0,[R1, #+0]
    142                        break;
    143              }              
    144          }
   \                     ??disable_irq_3: (+1)
   \   00000052   0x4770             BX       LR               ;; return
    145          /***********************************************************************/
    146          /*
    147           * Initialize the NVIC to set specified IRQ priority.
    148           * 
    149           * NOTE: The function only initializes the NVIC to set a single IRQ priority. 
    150           * Interrupts will also need to be enabled in the ARM core. This can be 
    151           * done using the EnableInterrupts macro.
    152           *
    153           * Parameters:
    154           * irq    irq number to be enabled (the irq number NOT the vector number)
    155           * prio   irq priority. 0-15 levels. 0 max priority
    156           */
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void set_irq_priority (int irq, int prio)
    159          {
    160              /*irq priority pointer*/
    161              uint8 *prio_reg;
    162              
    163              /* Make sure that the IRQ is an allowable number. Right now up to 91 is 
    164               * used.
    165               */
    166              //if (irq > 91)
    167              //    printf("\nERR! Invalid IRQ value passed to priority irq function!\n");
    168          
    169              //if (prio > 15)
    170              //    printf("\nERR! Invalid priority value passed to priority irq function!\n");
    171              
    172              /* Determine which of the NVICIPx corresponds to the irq */
    173              prio_reg = (uint8 *)(((uint32)&NVICIP0) + irq);
   \                     set_irq_priority: (+1)
   \   00000000   0xF100 0x4060      ADD      R0,R0,#-536870912
   \   00000004   0xF510 0x4064      ADDS     R0,R0,#+58368
    174              /* Assign priority to IRQ */
    175              *prio_reg = ( (prio&0xF) << (8 - ARM_INTERRUPT_LEVEL_BITS) );             
   \   00000008   0x0109             LSLS     R1,R1,#+4
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    176          }
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0xE000E284         DC32     0xe000e284

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0xE000E104         DC32     0xe000e104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0xE000E288         DC32     0xe000e288

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0xE000E108         DC32     0xe000e108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0xE000E184         DC32     0xe000e184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0xE000E188         DC32     0xe000e188
    177          /***********************************************************************/
    178          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   disable_irq
       4   enable_irq
       0   set_irq_priority
       0   stop
       0   wait
       0   write_vtor


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      84  disable_irq
     178  enable_irq
      14  set_irq_priority
      16  stop
      16  wait
       6  write_vtor

 
 358 bytes in section .text
 
 358 bytes of CODE memory

Errors: none
Warnings: none
