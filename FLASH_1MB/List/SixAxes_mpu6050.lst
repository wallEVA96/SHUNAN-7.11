###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      27/Nov/2014  19:27:57 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512VLQ15\ #
#                    ShunAn_Panel\SixAxes_mpu6050.c                           #
#    Command line =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512VLQ15\ #
#                    ShunAn_Panel\SixAxes_mpu6050.c -D IAR -D TWR_K60F120M    #
#                    -lCN D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512V #
#                    LQ15\FLASH_1MB\List\ -lB D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µ #
#                    ÈýºÅ\´úÂë\MK60FX512VLQ15\FLASH_1MB\List\ -o              #
#                    D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512VLQ15\ #
#                    FLASH_1MB\Obj\ --no_cse --no_unroll --no_inline          #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60F #
#                    X512VLQ15\ -I D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\M #
#                    K60FX512VLQ15\Library\ -I D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³° #
#                    µÈýºÅ\´úÂë\MK60FX512VLQ15\Library\BlessedAlien\ -I       #
#                    D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512VLQ15\ #
#                    ShunAn_Panel\ -Ol --use_c++_inline                       #
#    List file    =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512VLQ15\ #
#                    FLASH_1MB\List\SixAxes_mpu6050.lst                       #
#    Object file  =  D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512VLQ15\ #
#                    FLASH_1MB\Obj\SixAxes_mpu6050.o                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\´´×÷ÊÒ\·ÉË¼¿¨¶ûÖÇÄÜÐ¡³µ\Ë³°µÈýºÅ\´úÂë\MK60FX512VLQ15\ShunAn_Panel\SixAxes_mpu6050.c
      1          #include "arm_cm4.h"
      2          #include "MK60F15.h"
      3          #include "ShunAn_Lib.h"
      4          #include "start_ShunAn.h"
      5          
      6          #include "SixAxes_mpu6050.h"
      7          
      8          #include "IIC.h"
      9          #include "Bluetooth.h"
     10          

   \                                 In section .text, align 2, keep-with-next
     11          uint8 u8_mpu6050_RegInit(motionUnit * mpu)
     12          {
   \                     u8_mpu6050_RegInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     13              v_IIC_Init(); // IIC³õÊ¼»¯
   \   00000006   0x.... 0x....      BL       v_IIC_Init
     14              uint8 returnNum = 0; // ·µ»ØÊýÔÝ´æ
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
     15              if('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&returnNum,117)){return 'F';}; // ±ê¶¨MPU6050
   \   00000010   0x2375             MOVS     R3,#+117
   \   00000012   0xAA00             ADD      R2,SP,#+0
   \   00000014   0x2168             MOVS     R1,#+104
   \   00000016   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   00000018   0x.... 0x....      BL       u8_IIC_ReadReg
   \   0000001C   0x2846             CMP      R0,#+70
   \   0000001E   0xD101             BNE.N    ??u8_mpu6050_RegInit_0
   \   00000020   0x2046             MOVS     R0,#+70
   \   00000022   0xE044             B.N      ??u8_mpu6050_RegInit_1
     16              if(0x68 != returnNum){return 'F';}; // È·ÈÏMPU6050µÄÐòÁÐºÅ
   \                     ??u8_mpu6050_RegInit_0: (+1)
   \   00000024   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000028   0x2868             CMP      R0,#+104
   \   0000002A   0xD001             BEQ.N    ??u8_mpu6050_RegInit_2
   \   0000002C   0x2046             MOVS     R0,#+70
   \   0000002E   0xE03E             B.N      ??u8_mpu6050_RegInit_1
     17              if('F' == u8_IIC_WriteReg(I2C0_BASE_PTR,0x68,0    , 107)){return 'F';}; // ÅäÖÃÕñµ´
   \                     ??u8_mpu6050_RegInit_2: (+1)
   \   00000030   0x236B             MOVS     R3,#+107
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2168             MOVS     R1,#+104
   \   00000036   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   00000038   0x.... 0x....      BL       u8_IIC_WriteReg
   \   0000003C   0x2846             CMP      R0,#+70
   \   0000003E   0xD101             BNE.N    ??u8_mpu6050_RegInit_3
   \   00000040   0x2046             MOVS     R0,#+70
   \   00000042   0xE034             B.N      ??u8_mpu6050_RegInit_1
     18              if('F' == u8_IIC_WriteReg(I2C0_BASE_PTR,0x68,0    ,0x19)){return 'F';}; // ÅäÖÃÍÓÂÝÒÇÊä³ö 7
   \                     ??u8_mpu6050_RegInit_3: (+1)
   \   00000044   0x2319             MOVS     R3,#+25
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x2168             MOVS     R1,#+104
   \   0000004A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000004C   0x.... 0x....      BL       u8_IIC_WriteReg
   \   00000050   0x2846             CMP      R0,#+70
   \   00000052   0xD101             BNE.N    ??u8_mpu6050_RegInit_4
   \   00000054   0x2046             MOVS     R0,#+70
   \   00000056   0xE02A             B.N      ??u8_mpu6050_RegInit_1
     19              if('F' == u8_IIC_WriteReg(I2C0_BASE_PTR,0x68,0    ,0x1A)){return 'F';}; // ÅäÖÃµÍÍ¨ÂË²¨ 6
   \                     ??u8_mpu6050_RegInit_4: (+1)
   \   00000058   0x231A             MOVS     R3,#+26
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x2168             MOVS     R1,#+104
   \   0000005E   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   00000060   0x.... 0x....      BL       u8_IIC_WriteReg
   \   00000064   0x2846             CMP      R0,#+70
   \   00000066   0xD101             BNE.N    ??u8_mpu6050_RegInit_5
   \   00000068   0x2046             MOVS     R0,#+70
   \   0000006A   0xE020             B.N      ??u8_mpu6050_RegInit_1
     20              if('F' == u8_IIC_WriteReg(I2C0_BASE_PTR,0x68,0    ,0x1B)){return 'F';}; // ÅäÖÃGyro
   \                     ??u8_mpu6050_RegInit_5: (+1)
   \   0000006C   0x231B             MOVS     R3,#+27
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x2168             MOVS     R1,#+104
   \   00000072   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   00000074   0x.... 0x....      BL       u8_IIC_WriteReg
   \   00000078   0x2846             CMP      R0,#+70
   \   0000007A   0xD101             BNE.N    ??u8_mpu6050_RegInit_6
   \   0000007C   0x2046             MOVS     R0,#+70
   \   0000007E   0xE016             B.N      ??u8_mpu6050_RegInit_1
     21              if('F' == u8_IIC_WriteReg(I2C0_BASE_PTR,0x68,0    ,0x1C)){return 'F';}; // ÅäÖÃAccel
   \                     ??u8_mpu6050_RegInit_6: (+1)
   \   00000080   0x231C             MOVS     R3,#+28
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x2168             MOVS     R1,#+104
   \   00000086   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   00000088   0x.... 0x....      BL       u8_IIC_WriteReg
   \   0000008C   0x2846             CMP      R0,#+70
   \   0000008E   0xD101             BNE.N    ??u8_mpu6050_RegInit_7
   \   00000090   0x2046             MOVS     R0,#+70
   \   00000092   0xE00C             B.N      ??u8_mpu6050_RegInit_1
     22              mpu->Accel_Var.x = 0;
   \                     ??u8_mpu6050_RegInit_7: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x8020             STRH     R0,[R4, #+0]
     23              mpu->Accel_Var.y = 0;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x8060             STRH     R0,[R4, #+2]
     24              mpu->Accel_Var.z = 0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x80A0             STRH     R0,[R4, #+4]
     25              mpu->Gyro_Var.x = 0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x80E0             STRH     R0,[R4, #+6]
     26              mpu->Gyro_Var.y = 0;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x8120             STRH     R0,[R4, #+8]
     27              mpu->Gyro_Var.z = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x8160             STRH     R0,[R4, #+10]
     28              return 'T';
   \   000000AC   0x2054             MOVS     R0,#+84
   \                     ??u8_mpu6050_RegInit_1: (+1)
   \   000000AE   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     29          }
     30          

   \                                 In section .text, align 2, keep-with-next
     31          uint8 u8_GetAccel(motionUnit * getAccel)
     32          {
   \                     u8_GetAccel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     33              uint8 temp_H = 0; uint8 temp_L = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     34              if(('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_H,59))||('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_L,60)))
   \   00000012   0x233B             MOVS     R3,#+59
   \   00000014   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000018   0x2168             MOVS     R1,#+104
   \   0000001A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000001C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000020   0x2846             CMP      R0,#+70
   \   00000022   0xD007             BEQ.N    ??u8_GetAccel_0
   \   00000024   0x233C             MOVS     R3,#+60
   \   00000026   0xAA00             ADD      R2,SP,#+0
   \   00000028   0x2168             MOVS     R1,#+104
   \   0000002A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000002C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000030   0x2846             CMP      R0,#+70
   \   00000032   0xD101             BNE.N    ??u8_GetAccel_1
     35              {return 'F';}
   \                     ??u8_GetAccel_0: (+1)
   \   00000034   0x2046             MOVS     R0,#+70
   \   00000036   0xE047             B.N      ??u8_GetAccel_2
     36              getAccel->Accel_Var.x = ((temp_H << 8)|temp_L);
   \                     ??u8_GetAccel_1: (+1)
   \   00000038   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000003C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000040   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000044   0x8020             STRH     R0,[R4, #+0]
     37              temp_H = 0; temp_L = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     38              if(('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_H,61))||('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_L,62)))
   \   00000052   0x233D             MOVS     R3,#+61
   \   00000054   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000058   0x2168             MOVS     R1,#+104
   \   0000005A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000005C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000060   0x2846             CMP      R0,#+70
   \   00000062   0xD007             BEQ.N    ??u8_GetAccel_3
   \   00000064   0x233E             MOVS     R3,#+62
   \   00000066   0xAA00             ADD      R2,SP,#+0
   \   00000068   0x2168             MOVS     R1,#+104
   \   0000006A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000006C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000070   0x2846             CMP      R0,#+70
   \   00000072   0xD101             BNE.N    ??u8_GetAccel_4
     39              {return 'F';}
   \                     ??u8_GetAccel_3: (+1)
   \   00000074   0x2046             MOVS     R0,#+70
   \   00000076   0xE027             B.N      ??u8_GetAccel_2
     40              getAccel->Accel_Var.y = ((temp_H << 8)|temp_L);
   \                     ??u8_GetAccel_4: (+1)
   \   00000078   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000007C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000080   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000084   0x8060             STRH     R0,[R4, #+2]
     41              temp_H = 0; temp_L = 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     42              if(('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_H,63))||('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_L,64)))
   \   00000092   0x233F             MOVS     R3,#+63
   \   00000094   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000098   0x2168             MOVS     R1,#+104
   \   0000009A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000009C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   000000A0   0x2846             CMP      R0,#+70
   \   000000A2   0xD007             BEQ.N    ??u8_GetAccel_5
   \   000000A4   0x2340             MOVS     R3,#+64
   \   000000A6   0xAA00             ADD      R2,SP,#+0
   \   000000A8   0x2168             MOVS     R1,#+104
   \   000000AA   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   000000AC   0x.... 0x....      BL       u8_IIC_ReadReg
   \   000000B0   0x2846             CMP      R0,#+70
   \   000000B2   0xD101             BNE.N    ??u8_GetAccel_6
     43              {return 'F';}
   \                     ??u8_GetAccel_5: (+1)
   \   000000B4   0x2046             MOVS     R0,#+70
   \   000000B6   0xE007             B.N      ??u8_GetAccel_2
     44              getAccel->Accel_Var.z = ((temp_H << 8)|temp_L);
   \                     ??u8_GetAccel_6: (+1)
   \   000000B8   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000BC   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000C0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000C4   0x80A0             STRH     R0,[R4, #+4]
     45              return 'T';
   \   000000C6   0x2054             MOVS     R0,#+84
   \                     ??u8_GetAccel_2: (+1)
   \   000000C8   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     46          }
     47          

   \                                 In section .text, align 2, keep-with-next
     48          uint8 u8_GetGyro(motionUnit * getGyro)
     49          {
   \                     u8_GetGyro: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     50              uint8 temp_H = 0; uint8 temp_L = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     51              if(('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_H,67))||('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_L,68)))
   \   00000012   0x2343             MOVS     R3,#+67
   \   00000014   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000018   0x2168             MOVS     R1,#+104
   \   0000001A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000001C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000020   0x2846             CMP      R0,#+70
   \   00000022   0xD007             BEQ.N    ??u8_GetGyro_0
   \   00000024   0x2344             MOVS     R3,#+68
   \   00000026   0xAA00             ADD      R2,SP,#+0
   \   00000028   0x2168             MOVS     R1,#+104
   \   0000002A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000002C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000030   0x2846             CMP      R0,#+70
   \   00000032   0xD101             BNE.N    ??u8_GetGyro_1
     52              {return 'F';}
   \                     ??u8_GetGyro_0: (+1)
   \   00000034   0x2046             MOVS     R0,#+70
   \   00000036   0xE047             B.N      ??u8_GetGyro_2
     53              getGyro->Gyro_Var.x = ((temp_H << 8)|temp_L);
   \                     ??u8_GetGyro_1: (+1)
   \   00000038   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000003C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000040   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000044   0x80E0             STRH     R0,[R4, #+6]
     54              temp_H = 0; temp_L = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     55              if(('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_H,69))||('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_L,70)))
   \   00000052   0x2345             MOVS     R3,#+69
   \   00000054   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000058   0x2168             MOVS     R1,#+104
   \   0000005A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000005C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000060   0x2846             CMP      R0,#+70
   \   00000062   0xD007             BEQ.N    ??u8_GetGyro_3
   \   00000064   0x2346             MOVS     R3,#+70
   \   00000066   0xAA00             ADD      R2,SP,#+0
   \   00000068   0x2168             MOVS     R1,#+104
   \   0000006A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000006C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   00000070   0x2846             CMP      R0,#+70
   \   00000072   0xD101             BNE.N    ??u8_GetGyro_4
     56              {return 'F';}
   \                     ??u8_GetGyro_3: (+1)
   \   00000074   0x2046             MOVS     R0,#+70
   \   00000076   0xE027             B.N      ??u8_GetGyro_2
     57              getGyro->Gyro_Var.y = ((temp_H << 8)|temp_L);
   \                     ??u8_GetGyro_4: (+1)
   \   00000078   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000007C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000080   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   00000084   0x8120             STRH     R0,[R4, #+8]
     58              temp_H = 0; temp_L = 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xF88D 0x0000      STRB     R0,[SP, #+0]
     59              if(('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_H,71))||('F' == u8_IIC_ReadReg(I2C0_BASE_PTR,0x68,&temp_L,72)))
   \   00000092   0x2347             MOVS     R3,#+71
   \   00000094   0xF10D 0x0201      ADD      R2,SP,#+1
   \   00000098   0x2168             MOVS     R1,#+104
   \   0000009A   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   0000009C   0x.... 0x....      BL       u8_IIC_ReadReg
   \   000000A0   0x2846             CMP      R0,#+70
   \   000000A2   0xD007             BEQ.N    ??u8_GetGyro_5
   \   000000A4   0x2348             MOVS     R3,#+72
   \   000000A6   0xAA00             ADD      R2,SP,#+0
   \   000000A8   0x2168             MOVS     R1,#+104
   \   000000AA   0x....             LDR.N    R0,??DataTable2  ;; 0x40066000
   \   000000AC   0x.... 0x....      BL       u8_IIC_ReadReg
   \   000000B0   0x2846             CMP      R0,#+70
   \   000000B2   0xD101             BNE.N    ??u8_GetGyro_6
     60              {return 'F';}
   \                     ??u8_GetGyro_5: (+1)
   \   000000B4   0x2046             MOVS     R0,#+70
   \   000000B6   0xE007             B.N      ??u8_GetGyro_2
     61              getGyro->Gyro_Var.z = ((temp_H << 8)|temp_L);
   \                     ??u8_GetGyro_6: (+1)
   \   000000B8   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   000000BC   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000C0   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   \   000000C4   0x8160             STRH     R0,[R4, #+10]
     62              return 'T';
   \   000000C6   0x2054             MOVS     R0,#+84
   \                     ??u8_GetGyro_2: (+1)
   \   000000C8   0xBD16             POP      {R1,R2,R4,PC}    ;; return
     63          }
     64          

   \                                 In section .text, align 2, keep-with-next
     65          uint8 u8_TxMotionData(motionUnit * mpu6050)
     66          {
   \                     u8_TxMotionData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     67              v_Uart_TxInt16(0xFEA0); // ÆðÊ¼Î»
   \   00000004   0xF64F 0x60A0      MOVW     R0,#+65184
   \   00000008   0x.... 0x....      BL       v_Uart_TxInt16
     68              v_Uart_TxInt16(mpu6050->Gyro_Var.x);
   \   0000000C   0x88E0             LDRH     R0,[R4, #+6]
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x.... 0x....      BL       v_Uart_TxInt16
     69              v_Uart_TxInt16(mpu6050->Gyro_Var.y);
   \   00000014   0x8920             LDRH     R0,[R4, #+8]
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x.... 0x....      BL       v_Uart_TxInt16
     70              v_Uart_TxInt16(mpu6050->Gyro_Var.z);
   \   0000001C   0x8960             LDRH     R0,[R4, #+10]
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0x.... 0x....      BL       v_Uart_TxInt16
     71              v_Uart_TxInt16(mpu6050->Accel_Var.x);
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x.... 0x....      BL       v_Uart_TxInt16
     72              v_Uart_TxInt16(mpu6050->Accel_Var.y);
   \   0000002C   0x8860             LDRH     R0,[R4, #+2]
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0x.... 0x....      BL       v_Uart_TxInt16
     73              v_Uart_TxInt16(mpu6050->Accel_Var.z);
   \   00000034   0x88A0             LDRH     R0,[R4, #+4]
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0x.... 0x....      BL       v_Uart_TxInt16
     74              return 'T';
   \   0000003C   0x2054             MOVS     R0,#+84
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
     75          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40066000         DC32     0x40066000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   u8_GetAccel
        16   -> u8_IIC_ReadReg
      16   u8_GetGyro
        16   -> u8_IIC_ReadReg
       8   u8_TxMotionData
         8   -> v_Uart_TxInt16
      16   u8_mpu6050_RegInit
        16   -> u8_IIC_ReadReg
        16   -> u8_IIC_WriteReg
        16   -> v_IIC_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
     202  u8_GetAccel
     202  u8_GetGyro
      64  u8_TxMotionData
     176  u8_mpu6050_RegInit

 
 648 bytes in section .text
 
 648 bytes of CODE memory

Errors: none
Warnings: none
