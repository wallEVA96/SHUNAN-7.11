###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.60.1.5097/W32 for ARM      20/Jul/2015  01:04:02 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\ShunAn_Panel\Poet_InputInterface.c         #
#    Command line =  D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\ShunAn_Panel\Poet_InputInterface.c -D IAR  #
#                    -D TWR_K60F120M -lCN D:\创作室\飞思卡尔智能小车\顺暗三号 #
#                    \代码\顺暗三号-华南赛最后七天-7.11\FLASH_1MB\List\ -lB   #
#                    D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\FLASH_1MB\List\ -o                         #
#                    D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\FLASH_1MB\Obj\ --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=VFPv4_sp --dlib_config "C:\Program Files        #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\ -I D:\创作室\飞思卡尔智能小车\顺暗三号\代 #
#                    码\顺暗三号-华南赛最后七天-7.11\Library\ -I              #
#                    D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\Library\BlessedAlien\ -I                   #
#                    D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\ShunAn_Panel\ -Ol --use_c++_inline         #
#    List file    =  D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\FLASH_1MB\List\Poet_InputInterface.lst     #
#    Object file  =  D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛 #
#                    最后七天-7.11\FLASH_1MB\Obj\Poet_InputInterface.o        #
#                                                                             #
#                                                                             #
###############################################################################

D:\创作室\飞思卡尔智能小车\顺暗三号\代码\顺暗三号-华南赛最后七天-7.11\ShunAn_Panel\Poet_InputInterface.c
      1          #include "MK60F15.h"
      2          #include "ShunAn_Lib.h"
      3          #include "start_ShunAn.h"
      4          #include "BlessedAlien.h"
      5          
      6          #include "Poet_InputInterface.h"
      7          

   \                                 In section .bss, align 4
      8          s_Button_TimeInformation m_Button_Timer = {0};//按键计时器全局初始化
   \                     m_Button_Timer:
   \   00000000                      DS8 32
      9          
     10          

   \                                 In section .text, align 2, keep-with-next
     11          void v_ExInterface_Init ( void )
     12          {
     13              // 初始化拨码开关 / 按键
     14              SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK|SIM_SCGC5_PORTE_MASK);//使能PORTA、B时钟
   \                     v_ExInterface_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11  ;; 0x40048038
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x5008      ORRS     R0,R0,#0x2200
   \   00000008   0x....             LDR.N    R1,??DataTable11  ;; 0x40048038
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     15              
     16              PORTE_PCR24 |= 0x00000100u;//引脚复用选择普通IO()
   \   0000000C   0x....             LDR.N    R0,??DataTable11_1  ;; 0x4004d060
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000014   0x....             LDR.N    R1,??DataTable11_1  ;; 0x4004d060
   \   00000016   0x6008             STR      R0,[R1, #+0]
     17              PORTE_PCR25 |= 0x00000100u;//引脚复用选择普通IO()
   \   00000018   0x....             LDR.N    R0,??DataTable11_2  ;; 0x4004d064
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000020   0x....             LDR.N    R1,??DataTable11_2  ;; 0x4004d064
   \   00000022   0x6008             STR      R0,[R1, #+0]
     18              PORTE_PCR26 |= 0x00000100u;//引脚复用选择普通IO()
   \   00000024   0x....             LDR.N    R0,??DataTable11_3  ;; 0x4004d068
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000002C   0x....             LDR.N    R1,??DataTable11_3  ;; 0x4004d068
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     19              PORTE_PCR27 |= 0x00000100u;//引脚复用选择普通IO()
   \   00000030   0x....             LDR.N    R0,??DataTable11_4  ;; 0x4004d06c
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000038   0x....             LDR.N    R1,??DataTable11_4  ;; 0x4004d06c
   \   0000003A   0x6008             STR      R0,[R1, #+0]
     20              PORTE_PCR28 |= 0x00000100u;//引脚复用选择普通IO()
   \   0000003C   0x....             LDR.N    R0,??DataTable11_5  ;; 0x4004d070
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000044   0x....             LDR.N    R1,??DataTable11_5  ;; 0x4004d070
   \   00000046   0x6008             STR      R0,[R1, #+0]
     21              
     22              PORTA_PCR5  |= 0x00000100u;//引脚复用选择普通IO()
   \   00000048   0x....             LDR.N    R0,??DataTable11_6  ;; 0x40049014
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000050   0x....             LDR.N    R1,??DataTable11_6  ;; 0x40049014
   \   00000052   0x6008             STR      R0,[R1, #+0]
     23              
     24              PORTA_PCR24 |= 0x00000100u;//引脚复用选择普通IO()
   \   00000054   0x....             LDR.N    R0,??DataTable11_7  ;; 0x40049060
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000005C   0x....             LDR.N    R1,??DataTable11_7  ;; 0x40049060
   \   0000005E   0x6008             STR      R0,[R1, #+0]
     25              PORTA_PCR25 |= 0x00000100u;//引脚复用选择普通IO()
   \   00000060   0x....             LDR.N    R0,??DataTable11_8  ;; 0x40049064
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000068   0x....             LDR.N    R1,??DataTable11_8  ;; 0x40049064
   \   0000006A   0x6008             STR      R0,[R1, #+0]
     26              PORTA_PCR26 |= 0x00000100u;//引脚复用选择普通IO()
   \   0000006C   0x....             LDR.N    R0,??DataTable11_9  ;; 0x40049068
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000074   0x....             LDR.N    R1,??DataTable11_9  ;; 0x40049068
   \   00000076   0x6008             STR      R0,[R1, #+0]
     27              PORTA_PCR27 |= 0x00000100u;//引脚复用选择普通IO()
   \   00000078   0x....             LDR.N    R0,??DataTable11_10  ;; 0x4004906c
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000080   0x....             LDR.N    R1,??DataTable11_10  ;; 0x4004906c
   \   00000082   0x6008             STR      R0,[R1, #+0]
     28              PORTA_PCR12 |= 0x00000100u;//引脚复用选择普通IO()
   \   00000084   0x....             LDR.N    R0,??DataTable11_11  ;; 0x40049030
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000008C   0x....             LDR.N    R1,??DataTable11_11  ;; 0x40049030
   \   0000008E   0x6008             STR      R0,[R1, #+0]
     29              
     30              GPIOE_PDDR &= ~(1<<24);//引脚选择输入方向()
   \   00000090   0x....             LDR.N    R0,??DataTable11_12  ;; 0x400ff114
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   00000098   0x....             LDR.N    R1,??DataTable11_12  ;; 0x400ff114
   \   0000009A   0x6008             STR      R0,[R1, #+0]
     31              GPIOE_PDDR &= ~(1<<25);//引脚选择输入方向()
   \   0000009C   0x....             LDR.N    R0,??DataTable11_12  ;; 0x400ff114
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF030 0x7000      BICS     R0,R0,#0x2000000
   \   000000A4   0x....             LDR.N    R1,??DataTable11_12  ;; 0x400ff114
   \   000000A6   0x6008             STR      R0,[R1, #+0]
     32              GPIOE_PDDR &= ~(1<<26);//引脚选择输入方向()
   \   000000A8   0x....             LDR.N    R0,??DataTable11_12  ;; 0x400ff114
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   000000B0   0x....             LDR.N    R1,??DataTable11_12  ;; 0x400ff114
   \   000000B2   0x6008             STR      R0,[R1, #+0]
     33              GPIOE_PDDR &= ~(1<<27);//引脚选择输入方向()
   \   000000B4   0x....             LDR.N    R0,??DataTable11_12  ;; 0x400ff114
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   000000BC   0x....             LDR.N    R1,??DataTable11_12  ;; 0x400ff114
   \   000000BE   0x6008             STR      R0,[R1, #+0]
     34              GPIOE_PDDR &= ~(1<<28);//引脚选择输入方向()
   \   000000C0   0x....             LDR.N    R0,??DataTable11_12  ;; 0x400ff114
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \   000000C8   0x....             LDR.N    R1,??DataTable11_12  ;; 0x400ff114
   \   000000CA   0x6008             STR      R0,[R1, #+0]
     35              
     36              GPIOA_PDDR &= ~(1<<5);//引脚选择输入方向()
   \   000000CC   0x....             LDR.N    R0,??DataTable11_13  ;; 0x400ff014
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000000D4   0x....             LDR.N    R1,??DataTable11_13  ;; 0x400ff014
   \   000000D6   0x6008             STR      R0,[R1, #+0]
     37              
     38              GPIOA_PDDR &= ~(1<<24);//引脚选择输入方向()
   \   000000D8   0x....             LDR.N    R0,??DataTable11_13  ;; 0x400ff014
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   000000E0   0x....             LDR.N    R1,??DataTable11_13  ;; 0x400ff014
   \   000000E2   0x6008             STR      R0,[R1, #+0]
     39              GPIOA_PDDR &= ~(1<<25);//引脚选择输入方向()
   \   000000E4   0x....             LDR.N    R0,??DataTable11_13  ;; 0x400ff014
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0xF030 0x7000      BICS     R0,R0,#0x2000000
   \   000000EC   0x....             LDR.N    R1,??DataTable11_13  ;; 0x400ff014
   \   000000EE   0x6008             STR      R0,[R1, #+0]
     40              GPIOA_PDDR &= ~(1<<26);//引脚选择输入方向()
   \   000000F0   0x....             LDR.N    R0,??DataTable11_13  ;; 0x400ff014
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   000000F8   0x....             LDR.N    R1,??DataTable11_13  ;; 0x400ff014
   \   000000FA   0x6008             STR      R0,[R1, #+0]
     41              GPIOA_PDDR &= ~(1<<27);//引脚选择输入方向()
   \   000000FC   0x....             LDR.N    R0,??DataTable11_13  ;; 0x400ff014
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF030 0x6000      BICS     R0,R0,#0x8000000
   \   00000104   0x....             LDR.N    R1,??DataTable11_13  ;; 0x400ff014
   \   00000106   0x6008             STR      R0,[R1, #+0]
     42              GPIOA_PDDR &= ~(1<<12);//引脚选择输入方向()
   \   00000108   0x....             LDR.N    R0,??DataTable11_13  ;; 0x400ff014
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF430 0x5080      BICS     R0,R0,#0x1000
   \   00000110   0x....             LDR.N    R1,??DataTable11_13  ;; 0x400ff014
   \   00000112   0x6008             STR      R0,[R1, #+0]
     43          }
   \   00000114   0x4770             BX       LR               ;; return
     44          
     45          

   \                                 In section .text, align 2, keep-with-next
     46          unsigned char u8_ExInterface0_get(void){return (GPIOA_PDIR >> 24) & 0x01;}
   \                     u8_ExInterface0_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14  ;; 0x400ff010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0E00             LSRS     R0,R0,#+24
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     47          unsigned char u8_ExInterface1_get(void){return (GPIOA_PDIR >> 25) & 0x01;}
   \                     u8_ExInterface1_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14  ;; 0x400ff010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0E40             LSRS     R0,R0,#+25
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     48          unsigned char u8_ExInterface2_get(void){return (GPIOA_PDIR >> 26) & 0x01;}
   \                     u8_ExInterface2_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14  ;; 0x400ff010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0E80             LSRS     R0,R0,#+26
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     49          unsigned char u8_ExInterface3_get(void){return (GPIOA_PDIR >> 27) & 0x01;}
   \                     u8_ExInterface3_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14  ;; 0x400ff010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return
     50          

   \                                 In section .text, align 2, keep-with-next
     51          unsigned char u8_ExInterface4_get(void){return (GPIOA_PDIR >> 12) & 0x01;}
   \                     u8_ExInterface4_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14  ;; 0x400ff010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0B00             LSRS     R0,R0,#+12
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     52          unsigned char u8_ExInterface5_get(void){return (GPIOA_PDIR >> 5) & 0x01;}
   \                     u8_ExInterface5_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_14  ;; 0x400ff010
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF3C0 0x1040      UBFX     R0,R0,#+5,#+1
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     53          unsigned char u8_ExInterface6_get(void){return (GPIOE_PDIR >> 24) & 0x01;}
   \                     u8_ExInterface6_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_15  ;; 0x400ff110
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0E00             LSRS     R0,R0,#+24
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     54          unsigned char u8_ExInterface7_get(void){return (GPIOE_PDIR >> 25) & 0x01;}
   \                     u8_ExInterface7_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_15  ;; 0x400ff110
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0E40             LSRS     R0,R0,#+25
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return
     55          

   \                                 In section .text, align 2, keep-with-next
     56          unsigned char u8_ExInterface8_get(void){return (GPIOE_PDIR >> 26) & 0x01;}
   \                     u8_ExInterface8_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_15  ;; 0x400ff110
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0E80             LSRS     R0,R0,#+26
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     57          unsigned char u8_ExInterface9_get(void){return (GPIOE_PDIR >> 27) & 0x01;}
   \                     u8_ExInterface9_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_15  ;; 0x400ff110
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0EC0             LSRS     R0,R0,#+27
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     58          unsigned char u8_ExInterface10_get(void){return (GPIOE_PDIR >> 28) & 0x01;}
   \                     u8_ExInterface10_get: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable11_15  ;; 0x400ff110
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0F00             LSRS     R0,R0,#+28
   \   00000006   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x4004D060         DC32     0x4004d060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x4004D064         DC32     0x4004d064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x4004D068         DC32     0x4004d068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x4004D06C         DC32     0x4004d06c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x4004D070         DC32     0x4004d070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x40049014         DC32     0x40049014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x40049060         DC32     0x40049060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x40049064         DC32     0x40049064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x40049068         DC32     0x40049068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x4004906C         DC32     0x4004906c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x40049030         DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x400FF114         DC32     0x400ff114

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x400FF014         DC32     0x400ff014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x400FF010         DC32     0x400ff010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x400FF110         DC32     0x400ff110
     59          
     60          
     61          
     62          /*
     63          //#define DE_BUTTON_TICK  13
     64          Buttons g_Buttons;
     65          ExInterfaces g_ExInterfaces;
     66          */
     67          /*
     68          uint8 u8_Button_set(Message * _Message , Buttons * _Buttons , ExInterfaces * _ExInterfaces)
     69          {
     70              uint8 DownEventStart = 0;
     71              uint8 DownButton = 0;
     72              uint8 DownSwitch = 0;
     73              if( ( 0 == Button1 ) && ( _Buttons->BottonTotaltime - _Buttons->Button1time > DE_BUTTON_TICK ) )
     74              {
     75                  // 事件成立
     76                  DownButton |= 0x01;
     77                  DownEventStart = 1;
     78                  _Buttons->Button1time = _Buttons->BottonTotaltime;
     79              }
     80              if( ( 0 == Button2 ) && ( _Buttons->BottonTotaltime - _Buttons->Button2time > DE_BUTTON_TICK ) )
     81              {
     82                  // 事件成立
     83                  DownButton |= 0x02;
     84                  DownEventStart = 1;
     85                  _Buttons->Button2time = _Buttons->BottonTotaltime;
     86              }
     87              if( ( 0 == Button3 ) && ( _Buttons->BottonTotaltime - _Buttons->Button3time > DE_BUTTON_TICK ) )
     88              {
     89                  // 事件成立
     90                  DownButton |= 0x04;
     91                  DownEventStart = 1;
     92                  _Buttons->Button3time = _Buttons->BottonTotaltime;
     93              }
     94              if( ( 0 == Button4 ) && ( _Buttons->BottonTotaltime - _Buttons->Button4time > DE_BUTTON_TICK ) )
     95              {
     96                  // 事件成立
     97                  DownButton |= 0x08;
     98                  DownEventStart = 1;
     99                  _Buttons->Button4time = _Buttons->BottonTotaltime;
    100              }
    101              if(1 == DownEventStart)
    102              {
    103                  DownSwitch |= Switch1 << 0;
    104                  DownSwitch |= Switch2 << 1;
    105                  DownSwitch |= Switch3 << 2;
    106                  DownSwitch |= Switch4 << 3;
    107                  DownSwitch |= Switch5 << 4;
    108                  DownSwitch |= Switch6 << 5;
    109                  DownSwitch |= Switch7 << 6;
    110                  DownSwitch |= Switch8 << 7;
    111                  _ExInterfaces->ButtonsOn = DownButton;
    112                  _ExInterfaces->SwitchsOn = DownSwitch;
    113                  _Message->msgGaia = (void*)_ExInterfaces;
    114                  _Message->time = _Buttons->BottonTotaltime;
    115                  return 0;
    116              }
    117              return 1;
    118          }
    119          */
    120          
    121          /*
    122          #define Accel_SPI_PTR           SPI1_BASE_PTR
    123          uint8 b_Accel_DSPI_Init()
    124          {
    125              SIM_SCGC6 |= SIM_SCGC6_DSPI1_MASK; //
    126              SIM_SCGC5 |= SIM_SCGC5_PORTE_MASK;
    127              PORTE_BASE_PTR->PCR[0] = 0x00000200u; // 
    128              PORTE_BASE_PTR->PCR[1] = 0x00000200u; // 
    129              PORTE_BASE_PTR->PCR[2] = 0x00000200u; // 
    130              PORTE_BASE_PTR->PCR[3] = 0x00000200u; // 
    131              PORTE_BASE_PTR->PCR[4] = 0x00000200u; //
    132              Accel_SPI_PTR->MCR |= SPI_MCR_HALT_MASK; // 停止传输
    133              Accel_SPI_PTR->SR  = SPI_SR_EOQF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TFFF_MASK
    134                                      | SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK; // 集体清空 
    135              Accel_SPI_PTR->MCR = SPI_MCR_MSTR_MASK  | SPI_MCR_CLR_RXF_MASK | SPI_MCR_CLR_TXF_MASK | SPI_MCR_PCSIS(1) | SPI_MCR_PCSSE_SHIFT | SPI_MCR_CONT_SCKE_MASK
    136                                  | SPI_MCR_DIS_TXF_MASK | SPI_MCR_DIS_RXF_MASK | SPI_MCR_SMPL_PT(1);//SPI_MCR_PCSIS(1);
    137                                   //主机//接收清空//传输清空//片选位置
    138              
    139              Accel_SPI_PTR->CTAR[0] = SPI_CTAR_PBR(3) | SPI_CTAR_BR(5) | SPI_CTAR_CPOL_MASK | SPI_CTAR_CPHA_MASK// 分频
    140                                  | SPI_CTAR_FMSZ(7) ; // 位数
    141              Accel_SPI_PTR->MCR &=~SPI_MCR_HALT_MASK; // 使能传输
    142              
    143              uint8 returnNum = 0;
    144              if( 'F' == b_Accel_TxByte(0x80 | 0x0F,0)){return 'F';};
    145              if( 'F' == b_Accel_RxByte(&returnNum)){return 'F';};
    146              if(0xD7 != returnNum){return 'F';} // 目标确认
    147              return 'T';
    148          }
    149          
    150          uint8 b_Accel_RxByte(uint8 * returnNum)
    151          {
    152              uint8 time = 255;
    153              while( !((Accel_SPI_PTR->SR) & SPI_SR_RFDF_MASK) )
    154              {
    155                  if(!(time--)){return 'F';}  
    156              }
    157              *returnNum = (uint8)Accel_SPI_PTR->POPR;
    158              Accel_SPI_PTR->SR |= SPI_SR_RFDF_MASK;
    159              return 'T';
    160          }
    161          
    162          uint8 b_Accel_TxByte(uint8 returnNum,uint8 coun)
    163          {
    164              uint8 time = 255;
    165              do
    166              {
    167                  Accel_SPI_PTR->SR  |= SPI_SR_EOQF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TFFF_MASK
    168                                      | SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK;
    169                  Accel_SPI_PTR->MCR |= SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK;
    170                  if(!(time--)){return 'F';} 
    171              } while( (Accel_SPI_PTR->SR) & SPI_SR_RFDF_MASK );
    172              // 发送数据
    173              Accel_SPI_PTR->PUSHR = ( 0
    174                                           | SPI_PUSHR_CTAS(0)                 //选择CTAR0寄存器
    175                                           | SPI_PUSHR_PCS(1)
    176                                           | (coun << SPI_PUSHR_EOQ_SHIFT)                //1为 传输SPI最后的数据
    177                                           | SPI_PUSHR_TXDATA( returnNum )
    178                                           );
    179              //time = 255;
    180              //while(  (Accel_SPI_PTR->SR & SPI_SR_EOQF_MASK ) == 0 )       //等待传输完成
    181              //{
    182              //    if(!(time--)){return 'F';}
    183              //}
    184              return 'T';
    185          }
    186          */
    187          
    188          //#undef DE_BUTTON_TICK 
    189          
    190          /*
    191          
    192                      if(now_width * 3 <= m_ImageAbstract.width[y_ctr])//此次即认定为合适的
    193                      {//至此，我们应该选择一个很好的方式去忽略相应的黑色区域
    194                          //我们是否应该多次循迹还是说找个更方便的方法
    195                          //如果是左拐，我们应该继续左拐<=长斜入黑线障碍
    196                          //如果是左拐，我们应该更左拐？=>是否导致强烈的拐弯？<=楔形路障
    197                          //简单的方法=>继续相应寻线=>真实蛋疼的故事=>根据当前宽度进行匹配
    198                          do//进行多余的循迹
    199                          {
    200                              uint8 left_pluto_Pos = 255;
    201                              for (sint16 LINE_CTR = number_Trk.n_left_end;//此步为寻找左线
    202                                  LINE_CTR - constn_xFindJumpLine_Width >= constn_xFindJumpLine_Width;//限制幅度为最左
    203                                  LINE_CTR--)
    204                              {
    205                                  sint16 n_jumpVar = m_ImageBeholder_Data[y_ctr][LINE_CTR]//获取合适的跳变值
    206                                                   - m_ImageBeholder_Data[y_ctr][LINE_CTR - constn_xFindJumpLine_Width];
    207                                  sint16 absn_jumpVar = __ABS(n_jumpVar);//获取绝对值
    208                                  if ((absn_jumpVar > perLine_JumpNumVaild) && (absn_jumpVar > perLine_JumpNumNonVaild)
    209                                  && (n_jumpVar > 0)){left_pluto_Pos = LINE_CTR;break;}//=>寻找到下一个边沿
    210                              }//左线搜寻完毕
    211                              uint8 right_pluto_Pos = 255;
    212                              for (sint16 LINE_CTR = number_Trk.n_right_end;//此步为寻找右线
    213                                  LINE_CTR + constn_xFindJumpLine_Width < constNum_X_MaxCounter - constn_xFindJumpLine_Width;//限制幅度为最右
    214                                  LINE_CTR++)//向右提线
    215                              {
    216                                  sint16 n_jumpVar = m_ImageBeholder_Data[y_ctr][LINE_CTR]//获取合适的跳变值
    217                                                   - m_ImageBeholder_Data[y_ctr][LINE_CTR + constn_xFindJumpLine_Width];
    218                                  sint16 absn_jumpVar = __ABS(n_jumpVar);//获取绝对值
    219                                  if ((absn_jumpVar > perLine_JumpNumVaild) && (absn_jumpVar > perLine_JumpNumNonVaild)
    220                                   && (n_jumpVar > 0)){right_pluto_Pos = LINE_CTR;break;}//跳出本循环
    221                              }//右线搜寻完毕
    222                              
    223                              //存在三种宽度=>以下需要再次考虑
    224                              //左合适右合适
    225                              //左极限右合适
    226                              //左合适右极限
    227                              //左极限右极限 => 一般不考虑
    228                              
    229                              uint8 width_Left_Pluto = 0;
    230                              uint8 width_right_Pluto = 0;
    231                              
    232                              uint8 temp_cut_var[3] = {0,0,0};//三种差值
    233                              temp_cut_var[0] = __ABS(now_width - m_ImageAbstract.width[y_ctr]);
    234                              
    235                              if(255 != left_pluto_Pos)
    236                              {width_Left_Pluto = number_Trk.n_right_end - left_pluto_Pos;
    237                              temp_cut_var[1] = __ABS(width_Left_Pluto - m_ImageAbstract.width[y_ctr]);}
    238                              else{temp_cut_var[1] = 255;}
    239                              
    240                              if(255 != right_pluto_Pos)
    241                              {width_right_Pluto = right_pluto_Pos - number_Trk.n_left_end;
    242                              temp_cut_var[2] = __ABS(width_right_Pluto - m_ImageAbstract.width[y_ctr]);}
    243                              else{temp_cut_var[2] = 255;}
    244                              //以上为宽度搜索
    245                              uint8 min = 255;uint8 mark = 0;
    246                              for(uint8 loop = 0;loop < 3;loop++)
    247                              {
    248                                  if(min > temp_cut_var[loop]){min = temp_cut_var[loop];mark = loop;}
    249                              }
    250                              if(255 != min)
    251                              {
    252                                  if(1 == mark){number_Trk.n_left_end = left_pluto_Pos;}
    253                                  if(2 == mark){number_Trk.n_right_end = width_right_Pluto;}
    254                              }
    255                          }while(0);//至此，特殊处理完毕
    256                          
    257                      }
    258          */
    259          
    260          
    261              /*
    262              if(__ABS(process_find_timer - lostDouble_AllCounter) <= 1)
    263              {
    264                  m_Control.need_Hold = 1;
    265              }
    266              */
    267              /*
    268              if(all_height_Y_last_cut_first < 20)//小于此时将进入判定
    269              {
    270                  uint8 last = (all_height_Y_last_cut_first > 30)?30:all_height_Y_last_cut_first;
    271                  uint8 left_counter = 0;
    272                  uint8 right_counter = 0;
    273                  for(uint8 loop = m_ImageAbstract.Start_Y_Position;//整体循环
    274                            loop < last + m_ImageAbstract.Start_Y_Position;
    275                            loop ++)
    276                  {
    277                      if(255 == m_ImageAbstract.Left[loop]){left_counter++;}
    278                      if(255 == m_ImageAbstract.Right[loop]){right_counter++;}
    279                  }
    280                  if(((left_counter > all_height_Y_last_cut_first/2)
    281                    &&(right_counter > all_height_Y_last_cut_first/2))
    282                   ||(all_height_Y_last_cut_first < 10))
    283                  {
    284                      m_Control.need_Hold = 1;
    285                  }
    286                  else
    287                  {
    288                      
    289                      if(left_counter > all_height_Y_last_cut_first/2)
    290                      {
    291                          m_Control.need_TurnLeft = 1;
    292                      }
    293                      if(right_counter > all_height_Y_last_cut_first/2)
    294                      {
    295                          m_Control.need_TurnRight = 1;
    296                      }
    297                      
    298                  }
    299              }
    300              */
    301              /*
    302              do//重新全部管理数据
    303              {
    304                  sint16 all_height_Y_last_cut_first = m_ImageAbstract.Last_Y_Position - m_ImageAbstract.Start_Y_Position;
    305                  if(all_height_Y_last_cut_first < 25)//比30要小//Magic Number
    306                  {
    307                      float cutVar = 0; //30 - all_height_Y_last_cut_first;
    308                      for(uint8 loop = 0;loop < all_height_Y_last_cut_first;loop++)
    309                      {
    310                          uint8 Mark = m_ImageAbstract.Start_Y_Position + loop;
    311                          sint16 Central_Pos = 0;
    312                          do//额外搜线
    313                          {
    314                              
    315                          }while(0);
    316                          
    317                          if(255 == m_ImageAbstract.Left[Mark])
    318                          {
    319                              if(255 == m_ImageAbstract.Right[Mark])
    320                              {
    321                                  if(Mark > m_ImageAbstract.Start_Y_Position)
    322                                  {Central_Pos = m_ImageAbstract.Central[Mark - 1];}
    323                                  else
    324                                  {Central_Pos = m_ImageAbstract.LastFrame_CentralPos;}
    325                              }
    326                              else//(255 != m_ImageAbstract.Right[Mark])
    327                              {
    328                                  Central_Pos = (sint16)
    329                                ((m_ImageAbstract.Right[Mark] + constn_xFindJumpLine_Width)/2 - 3 * cutVar);
    330                              }
    331                          }
    332                          else//255 != m_ImageAbstract.Left[Mark]
    333                          {
    334                              if(255 == m_ImageAbstract.Right[Mark])
    335                              {
    336                                  Central_Pos = (sint16)
    337                                ((m_ImageAbstract.Left[Mark] + constNum_X_MaxCounter - constn_xFindJumpLine_Width)/2 + 2 * cutVar);
    338                              }
    339                              else//(255 != m_ImageAbstract.Right[Mark])
    340                              {//不用管
    341                              }
    342                          }//
    343                          cutVar += 30.f / all_height_Y_last_cut_first;
    344                          if(Central_Pos < constn_xFindJumpLine_Width){Central_Pos = constn_xFindJumpLine_Width;}
    345                          if(Central_Pos > constNum_X_MaxCounter - constn_xFindJumpLine_Width)
    346                          {Central_Pos = constNum_X_MaxCounter - constn_xFindJumpLine_Width;}
    347                          m_ImageAbstract.Central[Mark] = Central_Pos;
    348                          
    349                          if(m_ImageAbstract.Central[Mark] > constNum_X_MaxCounter - constn_xFindJumpLine_Width * 2)
    350                          {m_ImageAbstract.Central[Mark] = constNum_X_MaxCounter - constn_xFindJumpLine_Width * 2;}//限幅抑制信息
    351                          if(m_ImageAbstract.Central[Mark] < constn_xFindJumpLine_Width * 2)
    352                          {m_ImageAbstract.Central[Mark] = constn_xFindJumpLine_Width * 2;}
    353                      }
    354                  }
    355              }while(0);
    356              */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   u8_ExInterface0_get
       0   u8_ExInterface10_get
       0   u8_ExInterface1_get
       0   u8_ExInterface2_get
       0   u8_ExInterface3_get
       0   u8_ExInterface4_get
       0   u8_ExInterface5_get
       0   u8_ExInterface6_get
       0   u8_ExInterface7_get
       0   u8_ExInterface8_get
       0   u8_ExInterface9_get
       0   v_ExInterface_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      32  m_Button_Timer
      12  u8_ExInterface0_get
      12  u8_ExInterface10_get
      12  u8_ExInterface1_get
      12  u8_ExInterface2_get
      12  u8_ExInterface3_get
      12  u8_ExInterface4_get
      12  u8_ExInterface5_get
      12  u8_ExInterface6_get
      12  u8_ExInterface7_get
      12  u8_ExInterface8_get
      12  u8_ExInterface9_get
     278  v_ExInterface_Init

 
  32 bytes in section .bss
 474 bytes in section .text
 
 474 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
